This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
pom.xml
README.md
src/main/java/com/blockworlds/utags/AdminMenuListener.java
src/main/java/com/blockworlds/utags/AdminMenuManager.java
src/main/java/com/blockworlds/utags/ChangeNameColorCommand.java
src/main/java/com/blockworlds/utags/CustomTagRequest.java
src/main/java/com/blockworlds/utags/LoginListener.java
src/main/java/com/blockworlds/utags/LuckPermsListener.java
src/main/java/com/blockworlds/utags/NameColorMenuListener.java
src/main/java/com/blockworlds/utags/NameColorMenuManager.java
src/main/java/com/blockworlds/utags/NameCommand.java
src/main/java/com/blockworlds/utags/PlayerTagColorPreference.java
src/main/java/com/blockworlds/utags/RequestMenuClickListener.java
src/main/java/com/blockworlds/utags/Tag.java
src/main/java/com/blockworlds/utags/TagColorMenuListener.java
src/main/java/com/blockworlds/utags/TagColorMenuManager.java
src/main/java/com/blockworlds/utags/TagCommand.java
src/main/java/com/blockworlds/utags/TagCommandPreviewListener.java
src/main/java/com/blockworlds/utags/TagCreationData.java
src/main/java/com/blockworlds/utags/TagMenuListener.java
src/main/java/com/blockworlds/utags/TagMenuManager.java
src/main/java/com/blockworlds/utags/TagType.java
src/main/java/com/blockworlds/utags/uTags.java
src/main/resources/config.yml
src/main/resources/plugin.yml
uTags.iml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/blockworlds/utags/AdminMenuListener.java">
package com.blockworlds.utags;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;

public class AdminMenuListener implements Listener {

    private final uTags plugin;
    private final AdminMenuManager adminMenuManager;
    // Map to store ongoing tag creation processes
    private final Map<UUID, TagCreationData> tagCreationProcesses = new HashMap<>();

    // Map to track pending chat input for specific attributes
    private final Map<UUID, String> pendingAdminInput = new HashMap<>();
    public AdminMenuListener(uTags plugin, AdminMenuManager adminMenuManager) {
        this.plugin = plugin;
        this.adminMenuManager = adminMenuManager;
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player)) {
            return;
        }

        Player player = (Player) event.getWhoClicked();
        ItemStack clickedItem = event.getCurrentItem();
        String inventoryTitle = event.getView().getTitle();

        // Check if it's one of the admin menus or the creation wizard
        if (!isAdminMenu(inventoryTitle) && !inventoryTitle.startsWith(ChatColor.GREEN + "Create Tag:")) {
             return;
        }

        // Basic checks for valid clicks
        if (event.getRawSlot() < 0 || event.getRawSlot() >= event.getInventory().getSize()) {
            return; // Prevent clicking outside inventory bounds
        }

        event.setCancelled(true); // Cancel all clicks in admin menus (and wizard for now)

        if (clickedItem == null || clickedItem.getType() == Material.AIR || !clickedItem.hasItemMeta()) {
            return; // Ignore clicks on empty slots or items without meta
        }

        // Handle interaction based on the specific admin menu title
        handleAdminMenuInteraction(event, inventoryTitle);
    }

    private boolean isAdminMenu(String inventoryTitle) {
        // Add more titles as new admin menus are created
        return inventoryTitle.equals(ChatColor.DARK_RED + "uTags Admin Menu")
                || inventoryTitle.startsWith(ChatColor.AQUA + "Tag List")
                || inventoryTitle.startsWith(ChatColor.DARK_AQUA + "Edit Tag:")
                || inventoryTitle.startsWith(ChatColor.DARK_RED + "Confirm Purge:")
                || inventoryTitle.startsWith(ChatColor.DARK_RED + "Confirm Delete:")
                || inventoryTitle.equals(ChatColor.DARK_RED + "Select Purge Type")
                || inventoryTitle.startsWith(ChatColor.GREEN + "Create Tag:"); // Add creation wizard title
    }

    private void handleAdminMenuInteraction(InventoryClickEvent event, String inventoryTitle) {
        Player player = (Player) event.getWhoClicked();
        ItemStack clickedItem = event.getCurrentItem();
        ItemMeta meta = clickedItem.getItemMeta();
        String itemName = ChatColor.stripColor(meta.getDisplayName());

        if (inventoryTitle.equals(ChatColor.DARK_RED + "uTags Admin Menu")) {
            handleAdminMainMenuClick(player, itemName);
        } else if (inventoryTitle.startsWith(ChatColor.DARK_RED + "Confirm Purge:")) {
             handlePurgeConfirmClick(event, player, itemName, inventoryTitle);
        } else if (inventoryTitle.startsWith(ChatColor.AQUA + "Tag List")) {
             handleTagListClick(event, player, itemName, inventoryTitle);
        } else if (inventoryTitle.startsWith(ChatColor.DARK_AQUA + "Edit Tag:")) {
             handleTagEditorClick(event, player, itemName, inventoryTitle);
        } else if (inventoryTitle.startsWith(ChatColor.DARK_RED + "Confirm Delete:")) {
             handleDeleteConfirmClick(event, player, itemName, inventoryTitle);
        } else if (inventoryTitle.equals(ChatColor.DARK_RED + "Select Purge Type")) {
             handlePurgeTypeSelectionClick(event, player, itemName);
        } else if (inventoryTitle.startsWith(ChatColor.GREEN + "Create Tag:")) {
             handleCreationWizardClick(event, player, itemName); // Route to creation wizard handler
        }
        // TODO: Add else if blocks for other admin menus
    }

    private void handleAdminMainMenuClick(Player player, String itemName) {
        switch (itemName) {
            case "List / Edit Tags":
                adminMenuManager.openTagListMenu(player, 0);
                break;
            case "Create New Tag":
                // Start the creation wizard
                TagCreationData creationData = new TagCreationData();
                tagCreationProcesses.put(player.getUniqueId(), creationData);
                // Open the first step of the wizard
                adminMenuManager.openCreationWizardStep(player, creationData);
                break;
            case "Manage Requests":
                plugin.openRequestsMenu(player);
                break;
            case "Purge Data":
                adminMenuManager.openPurgeTypeSelectionMenu(player);
                break;
            default:
                // Clicked on frame or unknown item
                break;
        }
    } // End of handleAdminMainMenuClick


    // Handles clicks in the Purge Confirmation menu
    private void handlePurgeConfirmClick(InventoryClickEvent event, Player player, String itemName, String inventoryTitle) {
        if (itemName.startsWith("CONFIRM PURGE")) {
            String purgeType = null;
            if (itemName.contains("TAGS")) {
                purgeType = "tags";
            } else if (itemName.contains("REQUESTS")) {
                purgeType = "requests";
            }

            if (purgeType != null) {
                player.closeInventory();
                String command = "tag admin purge " + purgeType + " confirm";
                player.sendMessage(ChatColor.YELLOW + "Executing purge command: /" + command);
                Bukkit.dispatchCommand(player, command);
            } else {
                player.sendMessage(ChatColor.RED + "Error determining purge type from confirmation menu.");
                player.closeInventory();
            }
        } else if (itemName.equals("Cancel")) {
            adminMenuManager.openAdminMainMenu(player);
        }
    } // End of handlePurgeConfirmClick


    // Handles clicks in the Tag List menu
    private void handleTagListClick(InventoryClickEvent event, Player player, String itemName, String inventoryTitle) {
        int currentPage = 0;
        try {
            int pageStartIndex = inventoryTitle.indexOf("(Page ") + 6;
            int pageEndIndex = inventoryTitle.indexOf('/');
            if (pageStartIndex > 5 && pageEndIndex > pageStartIndex) { // Basic validation
                currentPage = Integer.parseInt(inventoryTitle.substring(pageStartIndex, pageEndIndex).trim()) - 1;
            }
        } catch (Exception e) {
            plugin.getLogger().warning("Could not parse page number from Tag List title: " + inventoryTitle);
        }

        switch (itemName) {
            case "Previous Page":
                adminMenuManager.openTagListMenu(player, currentPage - 1);
                break;
            case "Next Page":
                adminMenuManager.openTagListMenu(player, currentPage + 1);
                break;
            case "Back to Admin Menu":
                adminMenuManager.openAdminMainMenu(player);
                break;
            default:
                // Assume a tag item was clicked
                String tagName = null;
                ItemMeta meta = event.getCurrentItem().getItemMeta();
                if (meta != null && meta.hasLore()) {
                    for (String loreLine : meta.getLore()) {
                        String strippedLore = ChatColor.stripColor(loreLine);
                        if (strippedLore.startsWith("Name: ")) {
                            tagName = strippedLore.substring("Name: ".length());
                            break;
                        }
                    }
                }

                if (tagName != null) {
                    Tag tagToEdit = plugin.getTagByName(tagName);
                    if (tagToEdit != null) {
                        adminMenuManager.openTagEditorMenu(player, tagToEdit);
                    } else {
                        player.sendMessage(ChatColor.RED + "Error: Could not find tag data for '" + tagName + "' in the database.");
                        player.closeInventory();
                    }
                } else {
                    // Clicked on frame or failed to get tag name from lore
                }
                break;
        }
    } // End of handleTagListClick


    // Handles clicks in the Tag Editor menu
    private void handleTagEditorClick(InventoryClickEvent event, Player player, String itemName, String inventoryTitle) {
        String tagName = null;
        String titlePrefix = ChatColor.DARK_AQUA + "Edit Tag: " + ChatColor.AQUA;
        if (inventoryTitle.startsWith(titlePrefix)) {
            tagName = inventoryTitle.substring(titlePrefix.length());
            if (tagName.endsWith("...")) {
                 player.sendMessage(ChatColor.RED + "Error: Cannot reliably edit tag with truncated name in title.");
                 player.closeInventory();
                 return;
            }
        }

        if (tagName == null) {
             player.sendMessage(ChatColor.RED + "Error: Could not determine which tag is being edited.");
             player.closeInventory();
             return;
        }

        Tag currentTag = plugin.getTagByName(tagName);
        if (currentTag == null) {
            player.sendMessage(ChatColor.RED + "Error: Tag '" + tagName + "' no longer exists.");
            adminMenuManager.openTagListMenu(player, 0);
            return;
        }

        switch (itemName) {
            case "Back to Tag List":
                adminMenuManager.openTagListMenu(player, 0);
                break;

            case "DELETE TAG":
                adminMenuManager.openDeleteConfirmationMenu(player, currentTag);
                break;

            case "Name (Internal ID)":
                player.closeInventory();
                player.sendMessage(ChatColor.YELLOW + "To change the internal name (ID), use:");
                player.sendMessage(ChatColor.WHITE + "/tag admin edit " + tagName + " name <new_name>");
                player.sendMessage(ChatColor.RED + "Warning: Changing the name requires updating permissions manually!");
                break;

            case "Display Text":
                player.closeInventory();
                player.sendMessage(ChatColor.YELLOW + "To change the display text, use:");
                player.sendMessage(ChatColor.WHITE + "/tag admin edit " + tagName + " display <new_display_text>");
                player.sendMessage(ChatColor.GRAY + "(Use '&' for color codes)");
                break;

            case "Type":
                TagType nextType;
                switch (currentTag.getType()) {
                    case PREFIX: nextType = TagType.SUFFIX; break;
                    case SUFFIX: nextType = TagType.BOTH; break;
                    case BOTH: default: nextType = TagType.PREFIX; break;
                }
                if (plugin.editTagAttribute(tagName, "type", nextType.name())) {
                     player.sendMessage(ChatColor.GREEN + "Tag type set to " + nextType.name());
                     Tag updatedTag = plugin.getTagByName(tagName);
                     if (updatedTag != null) adminMenuManager.openTagEditorMenu(player, updatedTag); else player.closeInventory();
                } else {
                     player.sendMessage(ChatColor.RED + "Failed to update tag type.");
                }
                break;

            case "Weight (Sort Order)":
                player.closeInventory();
                player.sendMessage(ChatColor.YELLOW + "To change the weight (sort order), use:");
                player.sendMessage(ChatColor.WHITE + "/tag admin edit " + tagName + " weight <number>");
                player.sendMessage(ChatColor.GRAY + "(Higher weight appears first in lists)");
                break;

            case "Publicly Visible":
                boolean nextPublic = !currentTag.isPublic();
                if (plugin.editTagAttribute(tagName, "public", String.valueOf(nextPublic))) {
                     player.sendMessage(ChatColor.GREEN + "Tag visibility set to " + (nextPublic ? "Public" : "Private"));
                     Tag updatedTag = plugin.getTagByName(tagName);
                     if (updatedTag != null) adminMenuManager.openTagEditorMenu(player, updatedTag); else player.closeInventory();
                } else {
                     player.sendMessage(ChatColor.RED + "Failed to update tag visibility.");
                }
                break;

            case "Color Flag (Unused?)":
                boolean nextColor = !currentTag.isColor();
                if (plugin.editTagAttribute(tagName, "color", String.valueOf(nextColor))) {
                     player.sendMessage(ChatColor.GREEN + "Tag color flag set to " + nextColor);
                     Tag updatedTag = plugin.getTagByName(tagName);
                     if (updatedTag != null) adminMenuManager.openTagEditorMenu(player, updatedTag); else player.closeInventory();
                } else {
                     player.sendMessage(ChatColor.RED + "Failed to update tag color flag.");
                }
                break;

            case "Current Icon":
                 ItemStack cursorItem = event.getCursor();
                 if (cursorItem != null && cursorItem.getType() != Material.AIR) {
                     String newMaterialData = plugin.serializeMaterial(cursorItem);
                     if (plugin.editTagAttribute(tagName, "material", newMaterialData)) {
                         player.sendMessage(ChatColor.GREEN + "Tag icon updated!");
                         event.setCursor(null);
                         Tag updatedTag = plugin.getTagByName(tagName);
                         if (updatedTag != null) adminMenuManager.openTagEditorMenu(player, updatedTag); else player.closeInventory();
                     } else {
                          player.sendMessage(ChatColor.RED + "Failed to update tag icon.");
                     }
                 } else {
                     player.sendMessage(ChatColor.YELLOW + "Click this slot with the item you want to use as the new icon.");
                 }
                break;

            default:
                // Clicked on frame or unknown item
                break;
        }
    } // End of handleTagEditorClick


    // Handles clicks in the Delete Confirmation menu
    private void handleDeleteConfirmClick(InventoryClickEvent event, Player player, String itemName, String inventoryTitle) {
        String tagName = null;
        String titlePrefix = ChatColor.DARK_RED + "Confirm Delete: ";
        if (inventoryTitle.startsWith(titlePrefix)) {
            tagName = inventoryTitle.substring(titlePrefix.length());
             if (tagName.endsWith("...")) {
                 ItemStack infoItem = event.getInventory().getItem(4);
                 if (infoItem != null && infoItem.hasItemMeta() && infoItem.getItemMeta().hasLore()) {
                     for(String line : infoItem.getItemMeta().getLore()) {
                         String stripped = ChatColor.stripColor(line);
                         if (stripped.startsWith("Name: ")) {
                             tagName = stripped.substring("Name: ".length());
                             break;
                         }
                     }
                 }
                 if (tagName.endsWith("...")) {
                     player.sendMessage(ChatColor.RED + "Error: Cannot reliably delete tag with truncated name.");
                     player.closeInventory();
                     return;
                 }
            }
        }

         if (tagName == null) {
             player.sendMessage(ChatColor.RED + "Error: Could not determine which tag to delete.");
             player.closeInventory();
             return;
         }

        if (itemName.equals("CONFIRM DELETE")) {
            player.closeInventory();
            String command = "tag admin delete " + tagName;
            player.sendMessage(ChatColor.YELLOW + "Executing delete command: /" + command);
            Bukkit.dispatchCommand(player, command);
        } else if (itemName.equals("Cancel")) {
            Tag tagToEdit = plugin.getTagByName(tagName);
            if (tagToEdit != null) {
                adminMenuManager.openTagEditorMenu(player, tagToEdit);
            } else {
                player.sendMessage(ChatColor.RED + "Tag '" + tagName + "' seems to have been deleted. Returning to list.");
                adminMenuManager.openTagListMenu(player, 0);
            }
        }
    } // End of handleDeleteConfirmClick


    // Handles clicks in the Purge Type Selection menu
    private void handlePurgeTypeSelectionClick(InventoryClickEvent event, Player player, String itemName) {
        switch (itemName) {
            case "Purge ALL Tags":
                adminMenuManager.openPurgeConfirmationMenu(player, "tags");
                break;
            case "Purge ALL Requests":
                adminMenuManager.openPurgeConfirmationMenu(player, "requests");
                break;
            case "Cancel":
                adminMenuManager.openAdminMainMenu(player);
                break;
            default:
                // Clicked on frame or unknown item
                break;
        }
    } // End of handlePurgeTypeSelectionClick


    // Handles clicks in the Tag Creation Wizard menu
    private void handleCreationWizardClick(InventoryClickEvent event, Player player, String itemName) {
        TagCreationData data = tagCreationProcesses.get(player.getUniqueId());
        if (data == null) {
            player.sendMessage(ChatColor.RED + "Error: Could not find tag creation data. Please start again from /tag admin gui.");
            player.closeInventory();
            return; // Return early, don't go back to main menu automatically
        }

        switch (itemName) {
            case "Cancel Creation":
                tagCreationProcesses.remove(player.getUniqueId()); // Clean up map
                adminMenuManager.openAdminMainMenu(player); // Go back to main menu
                break;

            case "Confirm Creation":
                if (data.isComplete()) {
                    // Check if tag name already exists
                    if (plugin.getTagByName(data.getName()) != null) {
                        player.sendMessage(ChatColor.RED + "Error: A tag with the name '" + data.getName() + "' already exists.");
                        adminMenuManager.openCreationWizardStep(player, data); // Re-open wizard
                        return;
                    }
                    // Create the tag
                    Tag newTag = new Tag(data.getName(), data.getDisplay(), data.getType(), data.isPublic(), data.isColor(), data.getMaterial(), data.getWeight());
                    plugin.addTagToDatabase(newTag);
                    player.sendMessage(ChatColor.GREEN + "Tag '" + newTag.getName() + "' created successfully!");
                    tagCreationProcesses.remove(player.getUniqueId()); // Clean up map
                    adminMenuManager.openTagListMenu(player, 0); // Go to tag list
                } else {
                    player.sendMessage(ChatColor.RED + "Please set Name, Display, and Weight before confirming.");
                    // Refresh the menu to ensure button state is correct
                    adminMenuManager.openCreationWizardStep(player, data);
                }
                break;

            // --- Attribute Setters ---
            case "Set Name (Internal ID)":
                player.closeInventory();
                player.sendMessage(ChatColor.YELLOW + "Please type the desired internal name (ID) in chat.");
                player.sendMessage(ChatColor.GRAY + "(Letters, numbers, underscores, hyphens only. No spaces.)");
                player.sendMessage(ChatColor.GRAY + "Type 'cancel' to abort setting the name.");
                pendingAdminInput.put(player.getUniqueId(), "name");
                break;

            case "Set Display Text":
                 player.closeInventory();
                 player.sendMessage(ChatColor.YELLOW + "Please type the desired display text in chat.");
                 player.sendMessage(ChatColor.GRAY + "(Use '&' for color codes. Max 15 chars excluding codes. Must be in [])");
                 player.sendMessage(ChatColor.GRAY + "Type 'cancel' to abort setting the display text.");
                 pendingAdminInput.put(player.getUniqueId(), "display");
                break;

            case "Set Weight (Sort Order)":
                int currentWeight = data.getWeight();
                int newWeight = currentWeight; // Initialize with current value

                if (event.isShiftClick()) {
                    if (event.isLeftClick()) {
                        newWeight += 10; // Shift + Left = +10
                    } else if (event.isRightClick()) {
                        newWeight -= 10; // Shift + Right = -10
                    }
                } else {
                    if (event.isLeftClick()) {
                        newWeight += 1; // Left = +1
                    } else if (event.isRightClick()) {
                        newWeight -= 1; // Right = -1
                    }
                }

                // Enforce minimum weight of 1
                newWeight = Math.max(1, newWeight);

                if (newWeight != currentWeight) {
                    data.setWeight(newWeight);
                    player.sendMessage(ChatColor.GREEN + "Tag weight set to: " + newWeight);
                    adminMenuManager.openCreationWizardStep(player, data); // Refresh GUI
                } else {
                    // No change occurred (e.g., trying to decrease below 1)
                    // Optionally add feedback, or just do nothing
                }
                break;

            case "Set Type":
                TagType nextType;
                switch (data.getType()) {
                    case PREFIX: nextType = TagType.SUFFIX; break;
                    case SUFFIX: nextType = TagType.BOTH; break;
                    case BOTH: default: nextType = TagType.PREFIX; break;
                }
                data.setType(nextType);
                adminMenuManager.openCreationWizardStep(player, data); // Refresh GUI
                break;

            case "Set Publicly Visible":
                data.setPublic(!data.isPublic());
                adminMenuManager.openCreationWizardStep(player, data); // Refresh GUI
                break;

            case "Set Color Flag (Unused?)":
                data.setColor(!data.isColor());
                adminMenuManager.openCreationWizardStep(player, data); // Refresh GUI
                break;

            case "Set Icon":
                 ItemStack cursorItem = event.getCursor();
                 if (cursorItem != null && cursorItem.getType() != Material.AIR) {
                     data.setMaterial(cursorItem.clone()); // Set icon in data
                     event.setCursor(null); // Clear cursor
                     player.sendMessage(ChatColor.GREEN + "Icon set to " + data.getMaterial().getType().name());
                     adminMenuManager.openCreationWizardStep(player, data); // Refresh GUI
                 } else {
                     player.sendMessage(ChatColor.YELLOW + "Click this slot with the item you want to use as the icon in your cursor.");
                 }
                break;

            default:
                // Clicked on frame or unknown item
                break;
        }
    } // End of handleCreationWizardClick

    @EventHandler
    public void onAdminChatInput(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();
        UUID playerId = player.getUniqueId();
        String message = event.getMessage();

        // Check if this player is expected to provide input
        if (!pendingAdminInput.containsKey(playerId)) {
            return;
        }

        // Player is providing input, cancel the chat message from appearing globally
        event.setCancelled(true);

        String attributeToSet = pendingAdminInput.get(playerId);
        TagCreationData data = tagCreationProcesses.get(playerId);

        if (data == null) {
            player.sendMessage(ChatColor.RED + "Error: Could not find your tag creation session. Please start again.");
            pendingAdminInput.remove(playerId);
            return;
        }

        // Handle cancellation
        if (message.equalsIgnoreCase("cancel")) {
            player.sendMessage(ChatColor.YELLOW + "Cancelled setting " + attributeToSet + ".");
            pendingAdminInput.remove(playerId);
            // Re-open GUI on the main thread
            Bukkit.getScheduler().runTask(plugin, () -> adminMenuManager.openCreationWizardStep(player, data));
            return;
        }

        boolean success = false;
        String feedback = "";

        // Process input based on the attribute
        switch (attributeToSet) {
            case "name":
                // Basic validation: No spaces, allowed characters (adjust regex as needed)
                if (message.matches("^[a-zA-Z0-9_-]+$")) {
                    // Check if name already exists (case-insensitive check during creation)
                    if (plugin.getTagByName(message) != null) {
                         feedback = ChatColor.RED + "Error: A tag with the name '" + message + "' already exists.";
                    } else {
                        data.setName(message);
                        feedback = ChatColor.GREEN + "Tag name set to: " + message;
                        success = true;
                    }
                } else {
                    feedback = ChatColor.RED + "Invalid name. Use only letters, numbers, underscores, hyphens. No spaces.";
                }
                break;

            case "display":
                int firstBracket = message.indexOf('[');
                int lastBracket = message.lastIndexOf(']');

                // Validation: Must contain brackets in the correct order
                if (firstBracket != -1 && lastBracket != -1 && lastBracket > firstBracket) {
                    // Extract content between the first '[' and last ']'
                    String contentBetweenBrackets = message.substring(firstBracket + 1, lastBracket);
                    String strippedContent = ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&', contentBetweenBrackets));

                    // Length check on the stripped content between brackets
                    if (strippedContent.length() > 0 && strippedContent.length() <= 15) {
                        data.setDisplay(message); // Store the full input with color codes
                        feedback = ChatColor.GREEN + "Tag display set to: " + ChatColor.translateAlternateColorCodes('&', message);
                        success = true;
                    } else if (strippedContent.length() == 0) {
                        feedback = ChatColor.RED + "Invalid display text. Cannot be empty between brackets.";
                    } else { // Too long
                        feedback = ChatColor.RED + "Invalid display text. Content between brackets (excluding color codes) cannot exceed 15 characters.";
                    }
                } else {
                    feedback = ChatColor.RED + "Invalid display text format. Must contain '[' and ']' in the correct order (e.g., &a[MyTag]).";
                }
                break;

            // Weight is now handled by clicking in the GUI, removed from chat input

            default:
                feedback = ChatColor.RED + "Internal error: Unknown attribute to set.";
                break;
        }

        player.sendMessage(feedback);

        // Only remove pending input if successful or explicitly cancelled (handled above)
        if (success) {
            pendingAdminInput.remove(playerId);
        }

        // Re-open GUI on the main thread regardless of success/failure to show current state or error context
        Bukkit.getScheduler().runTask(plugin, () -> adminMenuManager.openCreationWizardStep(player, data));
    }

} // End of AdminMenuListener class
</file>

<file path="src/main/java/com/blockworlds/utags/AdminMenuManager.java">
package com.blockworlds.utags;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class AdminMenuManager {

    private final uTags plugin;
    private final TagMenuManager tagMenuManager; // For createInventoryFrame

    public AdminMenuManager(uTags plugin, TagMenuManager tagMenuManager) {
        this.plugin = plugin;
        this.tagMenuManager = tagMenuManager;
    }

    // Main Admin Menu
    public void openAdminMainMenu(Player player) {
        Inventory adminMenu = Bukkit.createInventory(player, 27, ChatColor.DARK_RED + "uTags Admin Menu"); // 3 rows

        // --- Placeholder Items ---
        ItemStack listEditItem = new ItemStack(Material.BOOKSHELF);
        ItemMeta listEditMeta = listEditItem.getItemMeta();
        if (listEditMeta != null) {
            listEditMeta.setDisplayName(ChatColor.AQUA + "List / Edit Tags");
            listEditMeta.setLore(Arrays.asList(ChatColor.GRAY + "View, modify, or delete existing tags."));
            listEditItem.setItemMeta(listEditMeta);
        }

        ItemStack createItem = new ItemStack(Material.ANVIL);
        ItemMeta createMeta = createItem.getItemMeta();
        if (createMeta != null) {
            createMeta.setDisplayName(ChatColor.GREEN + "Create New Tag");
            createMeta.setLore(Arrays.asList(ChatColor.GRAY + "Create a new tag using a GUI wizard."));
            createItem.setItemMeta(createMeta);
        }

        ItemStack requestsItem = new ItemStack(Material.WRITABLE_BOOK);
        ItemMeta requestsMeta = requestsItem.getItemMeta();
        if (requestsMeta != null) {
            requestsMeta.setDisplayName(ChatColor.YELLOW + "Manage Requests");
            requestsMeta.setLore(Arrays.asList(ChatColor.GRAY + "Accept or deny pending custom tag requests."));
            requestsItem.setItemMeta(requestsMeta);
        }

        ItemStack purgeItem = new ItemStack(Material.LAVA_BUCKET);
        ItemMeta purgeMeta = purgeItem.getItemMeta();
        if (purgeMeta != null) {
            purgeMeta.setDisplayName(ChatColor.RED + "Purge Data");
            purgeMeta.setLore(Arrays.asList(ChatColor.DARK_RED + "" + ChatColor.BOLD + "WARNING:",
                                           ChatColor.GRAY + "Permanently delete tags or requests.",
                                           ChatColor.GRAY + "Requires confirmation."));
            purgeItem.setItemMeta(purgeMeta);
        }

        // Example Layout
        adminMenu.setItem(10, listEditItem);
        adminMenu.setItem(12, createItem);
        adminMenu.setItem(14, requestsItem);
        adminMenu.setItem(16, purgeItem);

        player.openInventory(adminMenu);
    }


    // Opens the paginated list of all tags for viewing/editing
    public void openTagListMenu(Player player, int pageIndex) {
        List<Tag> allTags = plugin.getAvailableTags(null); // Get all tags regardless of type

        // Sort tags alphabetically by name for consistency
        allTags.sort(Comparator.comparing(Tag::getName, String.CASE_INSENSITIVE_ORDER));

        int itemsPerPage = 28; // 4 rows * 7 slots
        int totalPages = Math.max(1, (int) Math.ceil((double) allTags.size() / itemsPerPage)); // Ensure at least 1 page
        pageIndex = Math.max(0, Math.min(pageIndex, totalPages - 1)); // Clamp page index

        String title = ChatColor.AQUA + "Tag List (Page " + (pageIndex + 1) + "/" + totalPages + ")";
        Inventory inventory = tagMenuManager.createInventoryFrame(54, title, // Use common frame creator
                Material.valueOf(plugin.getConfig().getString("frame-material", "GRAY_STAINED_GLASS_PANE")), player); // Different frame color?

        int startIndex = pageIndex * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, allTags.size());

        int[] itemSlots = {10, 11, 12, 13, 14, 15, 16,
                           19, 20, 21, 22, 23, 24, 25,
                           28, 29, 30, 31, 32, 33, 34,
                           37, 38, 39, 40, 41, 42, 43};

        int slotIndex = 0;
        for (int i = startIndex; i < endIndex; i++) {
            if (slotIndex >= itemSlots.length) break;

            Tag tag = allTags.get(i);
            ItemStack tagItem = tag.getMaterial().clone();
            ItemMeta tagMeta = tagItem.getItemMeta();

            if (tagMeta != null) {
                tagMeta.setDisplayName(ChatColor.translateAlternateColorCodes('&', tag.getDisplay()));
                List<String> lore = new ArrayList<>();
                lore.add(ChatColor.GRAY + "Name: " + ChatColor.WHITE + tag.getName());
                lore.add(ChatColor.GRAY + "Type: " + ChatColor.WHITE + tag.getType());
                lore.add(ChatColor.GRAY + "Weight: " + ChatColor.WHITE + tag.getWeight());
                lore.add(ChatColor.GRAY + "Public: " + (tag.isPublic() ? ChatColor.GREEN + "Yes" : ChatColor.RED + "No"));
                // lore.add(ChatColor.GRAY + "Color: " + (tag.isColor() ? ChatColor.GREEN + "Yes" : ChatColor.RED + "No")); // Add if needed
                lore.add(" ");
                lore.add(ChatColor.YELLOW + "Click to Edit");
                // TODO: Add PDC with tag name
                tagMeta.setLore(lore);
                tagItem.setItemMeta(tagMeta);
            }
            inventory.setItem(itemSlots[slotIndex], tagItem);
            slotIndex++;
        }

        // Navigation Items
        if (pageIndex > 0) {
            ItemStack prevPage = new ItemStack(Material.ARROW);
            ItemMeta prevMeta = prevPage.getItemMeta();
            if (prevMeta != null) {
                prevMeta.setDisplayName(ChatColor.AQUA + "Previous Page");
                prevPage.setItemMeta(prevMeta);
            }
            inventory.setItem(45, prevPage); // Bottom left
        }
        if ((pageIndex + 1) < totalPages) {
            ItemStack nextPage = new ItemStack(Material.ARROW);
            ItemMeta nextMeta = nextPage.getItemMeta();
             if (nextMeta != null) {
                nextMeta.setDisplayName(ChatColor.AQUA + "Next Page");
                nextPage.setItemMeta(nextMeta);
            }
            inventory.setItem(53, nextPage); // Bottom right
        }

        // Back to Main Admin Menu Item
        ItemStack backItem = new ItemStack(Material.BARRIER); // Or other item
        ItemMeta backMeta = backItem.getItemMeta();
        if (backMeta != null) {
            backMeta.setDisplayName(ChatColor.RED + "Back to Admin Menu");
            backItem.setItemMeta(backMeta);
        }
        inventory.setItem(49, backItem); // Bottom center

        player.openInventory(inventory);
    }


    // Opens the editor menu for a specific tag
    public void openTagEditorMenu(Player player, Tag tag) {
        String title = ChatColor.DARK_AQUA + "Edit Tag: " + ChatColor.AQUA + tag.getName();
        // Ensure title length is okay
        if (title.length() > 32) {
            title = title.substring(0, 29) + "...";
        }
        Inventory editorMenu = Bukkit.createInventory(player, 27, title); // 3 rows

        // --- Items representing attributes ---

        // Current Icon (Display Only + Edit Instruction) - Slot 4
        ItemStack iconItem = tag.getMaterial().clone();
        ItemMeta iconMeta = iconItem.getItemMeta();
        if (iconMeta != null) {
            iconMeta.setDisplayName(ChatColor.YELLOW + "Current Icon");
            List<String> iconLore = new ArrayList<>();
            iconLore.add(ChatColor.GRAY + "Material: " + ChatColor.WHITE + iconItem.getType().name());
            iconLore.add(" ");
            iconLore.add(ChatColor.AQUA + "Click with new item");
            iconLore.add(ChatColor.AQUA + "to change icon.");
            iconMeta.setLore(iconLore);
            // Store tag name in PDC
            // TODO: Implement PDC
            // iconMeta.getPersistentDataContainer().set(new NamespacedKey(plugin, "utag_editing_name"), PersistentDataType.STRING, tag.getName());
            iconItem.setItemMeta(iconMeta);
        }
        editorMenu.setItem(4, iconItem); // Center top row

        // Name - Slot 10
        ItemStack nameItem = new ItemStack(Material.NAME_TAG);
        ItemMeta nameMeta = nameItem.getItemMeta();
        if (nameMeta != null) {
            nameMeta.setDisplayName(ChatColor.GREEN + "Name (Internal ID)");
            nameMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + ChatColor.WHITE + tag.getName(),
                    " ",
                    ChatColor.YELLOW + "Click for command info" // Changed lore
            ));
            nameItem.setItemMeta(nameMeta);
        }
        editorMenu.setItem(10, nameItem);

        // Display - Slot 11
        ItemStack displayItem = new ItemStack(Material.PAPER);
        ItemMeta displayMeta = displayItem.getItemMeta();
        if (displayMeta != null) {
            displayMeta.setDisplayName(ChatColor.GREEN + "Display Text");
            displayMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + ChatColor.translateAlternateColorCodes('&', tag.getDisplay()),
                    " ",
                    ChatColor.YELLOW + "Click for command info" // Changed lore
            ));
            displayItem.setItemMeta(displayMeta);
        }
        editorMenu.setItem(11, displayItem);

        // Type - Slot 12
        ItemStack typeItem = new ItemStack(Material.COMPARATOR);
        ItemMeta typeMeta = typeItem.getItemMeta();
        if (typeMeta != null) {
            typeMeta.setDisplayName(ChatColor.GREEN + "Type");
            typeMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + ChatColor.WHITE + tag.getType().name(),
                    " ",
                    ChatColor.YELLOW + "Click to cycle (PREFIX/SUFFIX/BOTH)"
            ));
            typeItem.setItemMeta(typeMeta);
        }
        editorMenu.setItem(12, typeItem);

        // Weight - Slot 13
        ItemStack weightItem = new ItemStack(Material.ANVIL); // Or FEATHER?
        ItemMeta weightMeta = weightItem.getItemMeta();
        if (weightMeta != null) {
            weightMeta.setDisplayName(ChatColor.GREEN + "Weight (Sort Order)");
            weightMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + ChatColor.WHITE + tag.getWeight(),
                    ChatColor.GRAY + "(Higher weight appears first)",
                    " ",
                    ChatColor.YELLOW + "Click for command info" // Changed lore
            ));
            weightItem.setItemMeta(weightMeta);
        }
        editorMenu.setItem(13, weightItem);

        // Public - Slot 14
        ItemStack publicItem = new ItemStack(tag.isPublic() ? Material.LIME_DYE : Material.GRAY_DYE);
        ItemMeta publicMeta = publicItem.getItemMeta();
        if (publicMeta != null) {
            publicMeta.setDisplayName(ChatColor.GREEN + "Publicly Visible");
            publicMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + (tag.isPublic() ? ChatColor.GREEN + "Yes" : ChatColor.RED + "No"),
                    ChatColor.GRAY + "(Can players without specific perm see it?)",
                    " ",
                    ChatColor.YELLOW + "Click to toggle"
            ));
            publicItem.setItemMeta(publicMeta);
        }
        editorMenu.setItem(14, publicItem);

        // Color (Placeholder - Keep or Remove?) - Slot 15
        ItemStack colorItem = new ItemStack(tag.isColor() ? Material.ORANGE_DYE : Material.GRAY_DYE);
        ItemMeta colorMeta = colorItem.getItemMeta();
        if (colorMeta != null) {
            colorMeta.setDisplayName(ChatColor.GREEN + "Color Flag (Unused?)");
            colorMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + (tag.isColor() ? ChatColor.GREEN + "Yes" : ChatColor.RED + "No"),
                    " ",
                    ChatColor.YELLOW + "Click to toggle"
            ));
            colorItem.setItemMeta(colorMeta);
        }
        editorMenu.setItem(15, colorItem);


        // --- Action Buttons ---

        // Back Button - Slot 18 (Bottom Left)
        ItemStack backItem = new ItemStack(Material.ARROW);
        ItemMeta backMeta = backItem.getItemMeta();
        if (backMeta != null) {
            backMeta.setDisplayName(ChatColor.AQUA + "Back to Tag List");
            backItem.setItemMeta(backMeta);
        }
        editorMenu.setItem(18, backItem);

        // Delete Button - Slot 22 (Bottom Center)
        ItemStack deleteItem = new ItemStack(Material.BARRIER);
        ItemMeta deleteMeta = deleteItem.getItemMeta();
        if (deleteMeta != null) {
            deleteMeta.setDisplayName(ChatColor.RED + "" + ChatColor.BOLD + "DELETE TAG");
            deleteMeta.setLore(Arrays.asList(
                    ChatColor.YELLOW + "Click to permanently delete this tag.",
                    ChatColor.DARK_RED + "Requires confirmation."
            ));
            deleteItem.setItemMeta(deleteMeta);
        }
        editorMenu.setItem(22, deleteItem);

        player.openInventory(editorMenu);
    }




    // Opens a menu to select which data type to purge
    public void openPurgeTypeSelectionMenu(Player player) {
        Inventory selectionMenu = Bukkit.createInventory(player, 9, ChatColor.DARK_RED + "Select Purge Type");

        // Purge Tags Item
        ItemStack tagsItem = new ItemStack(Material.BOOKSHELF); // Or other representative item
        ItemMeta tagsMeta = tagsItem.getItemMeta();
        if (tagsMeta != null) {
            tagsMeta.setDisplayName(ChatColor.RED + "Purge ALL Tags");
            tagsMeta.setLore(Arrays.asList(
                ChatColor.YELLOW + "Click to delete all defined tags.",
                ChatColor.DARK_RED + "Requires further confirmation."
            ));
            tagsItem.setItemMeta(tagsMeta);
        }

        // Purge Requests Item
        ItemStack requestsItem = new ItemStack(Material.WRITABLE_BOOK); // Or other item
        ItemMeta requestsMeta = requestsItem.getItemMeta();
        if (requestsMeta != null) {
            requestsMeta.setDisplayName(ChatColor.RED + "Purge ALL Requests");
            requestsMeta.setLore(Arrays.asList(
                ChatColor.YELLOW + "Click to delete all pending tag requests.",
                ChatColor.DARK_RED + "Requires further confirmation."
            ));
            requestsItem.setItemMeta(requestsMeta);
        }

        // Cancel Item
        ItemStack cancelItem = new ItemStack(Material.BARRIER);
        ItemMeta cancelMeta = cancelItem.getItemMeta();
        if (cancelMeta != null) {
            cancelMeta.setDisplayName(ChatColor.GREEN + "Cancel");
            cancelMeta.setLore(Arrays.asList(ChatColor.GRAY + "Return to the main admin menu."));
            cancelItem.setItemMeta(cancelMeta);
        }

        // Layout: [T] [T] [T] [R] [R] [R] [C] [C] [C] (T=Tags, R=Requests, C=Cancel) - Example
        selectionMenu.setItem(2, tagsItem);
        selectionMenu.setItem(4, requestsItem);
        selectionMenu.setItem(6, cancelItem);

        player.openInventory(selectionMenu);
    }

    // Opens a confirmation menu for deleting a specific tag
    public void openDeleteConfirmationMenu(Player player, Tag tagToDelete) {
        String title = ChatColor.DARK_RED + "Confirm Delete: " + tagToDelete.getName();
        if (title.length() > 32) {
             title = title.substring(0, 29) + "...";
        }
        Inventory confirmMenu = Bukkit.createInventory(player, 9, title);

        // Tag Info Item (Display Only)
        ItemStack infoItem = tagToDelete.getMaterial().clone();
        ItemMeta infoMeta = infoItem.getItemMeta();
        if (infoMeta != null) {
            infoMeta.setDisplayName(ChatColor.YELLOW + "Delete This Tag?");
            infoMeta.setLore(Arrays.asList(
                ChatColor.GRAY + "Name: " + ChatColor.WHITE + tagToDelete.getName(),
                ChatColor.GRAY + "Display: " + ChatColor.translateAlternateColorCodes('&', tagToDelete.getDisplay()),
                " ",
                ChatColor.DARK_RED + "This action cannot be undone!"
            ));
            // Store tag name in PDC for listener
            // TODO: Implement PDC
            // infoMeta.getPersistentDataContainer().set(new NamespacedKey(plugin, "utag_delete_name"), PersistentDataType.STRING, tagToDelete.getName());
            infoItem.setItemMeta(infoMeta);
        }

        // Confirm Delete Item (Red Wool)
        ItemStack confirmItem = new ItemStack(Material.RED_WOOL);
        ItemMeta confirmMeta = confirmItem.getItemMeta();
        if (confirmMeta != null) {
            confirmMeta.setDisplayName(ChatColor.RED + "" + ChatColor.BOLD + "CONFIRM DELETE");
            confirmMeta.setLore(Arrays.asList(ChatColor.YELLOW + "Click to permanently delete tag '" + tagToDelete.getName() + "'."));
            confirmItem.setItemMeta(confirmMeta);
        }

        // Cancel Item (Green Wool)
        ItemStack cancelItem = new ItemStack(Material.GREEN_WOOL);
        ItemMeta cancelMeta = cancelItem.getItemMeta();
        if (cancelMeta != null) {
            cancelMeta.setDisplayName(ChatColor.GREEN + "Cancel");
            cancelMeta.setLore(Arrays.asList(ChatColor.GRAY + "Return to the tag editor."));
            cancelItem.setItemMeta(cancelMeta);
        }

        // Layout: [X] [X] [C] [X] [I] [X] [A] [X] [X] (C=Confirm, I=Info, A=Cancel) - Adjusted
        confirmMenu.setItem(2, confirmItem);
        confirmMenu.setItem(4, infoItem);
        confirmMenu.setItem(6, cancelItem);

        player.openInventory(confirmMenu);
    }


    // Opens the main creation wizard step GUI
    public void openCreationWizardStep(Player player, TagCreationData data) {
        String title = ChatColor.GREEN + "Create Tag: Step 1"; // Or just "Create Tag"
        Inventory wizardMenu = Bukkit.createInventory(player, 36, title); // 4 rows

        // --- Display Current Values & Actions ---

        // Name - Slot 10
        ItemStack nameItem = new ItemStack(Material.NAME_TAG);
        ItemMeta nameMeta = nameItem.getItemMeta();
        if (nameMeta != null) {
            nameMeta.setDisplayName(ChatColor.AQUA + "Set Name (Internal ID)");
            List<String> lore = new ArrayList<>();
            if (data.getName() != null) {
                lore.add(ChatColor.GRAY + "Current: " + ChatColor.WHITE + data.getName());
            } else {
                lore.add(ChatColor.GRAY + "Current: " + ChatColor.RED + "Not Set");
            }
            lore.add(" ");
            lore.add(ChatColor.YELLOW + "Click to set via chat command");
            nameMeta.setLore(lore);
            nameItem.setItemMeta(nameMeta);
        }
        wizardMenu.setItem(10, nameItem);

        // Display - Slot 11
        ItemStack displayItem = new ItemStack(Material.PAPER);
        ItemMeta displayMeta = displayItem.getItemMeta();
         if (displayMeta != null) {
            displayMeta.setDisplayName(ChatColor.AQUA + "Set Display Text");
             List<String> lore = new ArrayList<>();
            if (data.getDisplay() != null) {
                lore.add(ChatColor.GRAY + "Current: " + ChatColor.translateAlternateColorCodes('&', data.getDisplay()));
            } else {
                lore.add(ChatColor.GRAY + "Current: " + ChatColor.RED + "Not Set");
            }
            lore.add(" ");
            lore.add(ChatColor.YELLOW + "Click to set via chat command");
            lore.add(ChatColor.GRAY + "(Use '&' for color codes)");
            displayMeta.setLore(lore);
            displayItem.setItemMeta(displayMeta);
        }
        wizardMenu.setItem(11, displayItem);

        // Type - Slot 12
        ItemStack typeItem = new ItemStack(Material.COMPARATOR);
        ItemMeta typeMeta = typeItem.getItemMeta();
        if (typeMeta != null) {
            typeMeta.setDisplayName(ChatColor.AQUA + "Set Type");
            typeMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + ChatColor.WHITE + data.getType().name(),
                    " ",
                    ChatColor.YELLOW + "Click to cycle (PREFIX/SUFFIX/BOTH)"
            ));
            typeItem.setItemMeta(typeMeta);
        }
        wizardMenu.setItem(12, typeItem);

        // Weight - Slot 13
        ItemStack weightItem = new ItemStack(Material.ANVIL);
        ItemMeta weightMeta = weightItem.getItemMeta();
        if (weightMeta != null) {
            weightMeta.setDisplayName(ChatColor.AQUA + "Set Weight (Sort Order)");
             List<String> lore = new ArrayList<>();
            // Weight is now an int with a default, always has a value
            lore.add(ChatColor.GRAY + "Current: " + ChatColor.WHITE + data.getWeight());
            lore.add(ChatColor.GRAY + "(Higher weight appears first)");
            lore.add(" ");
            lore.add(ChatColor.YELLOW + "Left-Click: " + ChatColor.WHITE + "+1");
            lore.add(ChatColor.YELLOW + "Right-Click: " + ChatColor.WHITE + "-1");
            lore.add(ChatColor.YELLOW + "Shift + Left-Click: " + ChatColor.WHITE + "+10");
            lore.add(ChatColor.YELLOW + "Shift + Right-Click: " + ChatColor.WHITE + "-10");
            lore.add(ChatColor.GRAY + "(Min weight: 1)");
            lore.add(" ");
            lore.add(ChatColor.YELLOW + "Click to set via chat command");
            weightMeta.setLore(lore);
            weightItem.setItemMeta(weightMeta);
        }
        wizardMenu.setItem(13, weightItem);

        // Public - Slot 14
        ItemStack publicItem = new ItemStack(data.isPublic() ? Material.LIME_DYE : Material.GRAY_DYE);
        ItemMeta publicMeta = publicItem.getItemMeta();
        if (publicMeta != null) {
            publicMeta.setDisplayName(ChatColor.AQUA + "Set Publicly Visible");
            publicMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + (data.isPublic() ? ChatColor.GREEN + "Yes" : ChatColor.RED + "No"),
                    " ",
                    ChatColor.YELLOW + "Click to toggle"
            ));
            publicItem.setItemMeta(publicMeta);
        }
        wizardMenu.setItem(14, publicItem);

        // Color - Slot 15
        ItemStack colorItem = new ItemStack(data.isColor() ? Material.ORANGE_DYE : Material.GRAY_DYE);
        ItemMeta colorMeta = colorItem.getItemMeta();
        if (colorMeta != null) {
            colorMeta.setDisplayName(ChatColor.AQUA + "Set Color Flag (Unused?)");
             colorMeta.setLore(Arrays.asList(
                    ChatColor.GRAY + "Current: " + (data.isColor() ? ChatColor.GREEN + "Yes" : ChatColor.RED + "No"),
                    " ",
                    ChatColor.YELLOW + "Click to toggle"
            ));
            colorItem.setItemMeta(colorMeta);
        }
        wizardMenu.setItem(15, colorItem);

        // Icon - Slot 16
        ItemStack iconItem = data.getMaterial().clone(); // Show current icon
        ItemMeta iconMeta = iconItem.getItemMeta();
        if (iconMeta != null) {
            iconMeta.setDisplayName(ChatColor.AQUA + "Set Icon");
            iconMeta.setLore(Arrays.asList(
                ChatColor.GRAY + "Current: " + ChatColor.WHITE + iconItem.getType().name(),
                " ",
                ChatColor.YELLOW + "Click with item on cursor",
                ChatColor.YELLOW + "to set new icon."
            ));
            iconItem.setItemMeta(iconMeta);
        }
        wizardMenu.setItem(16, iconItem);


        // --- Control Buttons ---

        // Cancel Button - Slot 27 (Bottom Left)
        ItemStack cancelItem = new ItemStack(Material.BARRIER);
        ItemMeta cancelMeta = cancelItem.getItemMeta();
        if (cancelMeta != null) {
            cancelMeta.setDisplayName(ChatColor.RED + "Cancel Creation");
            cancelMeta.setLore(Arrays.asList(ChatColor.GRAY + "Discard changes and exit."));
            cancelItem.setItemMeta(cancelMeta);
        }
        wizardMenu.setItem(27, cancelItem);

        // Confirm Button - Slot 35 (Bottom Right) - Only enable if complete?
        Material confirmMat = data.isComplete() ? Material.GREEN_WOOL : Material.GRAY_WOOL;
        ItemStack confirmItem = new ItemStack(confirmMat);
        ItemMeta confirmMeta = confirmItem.getItemMeta();
        if (confirmMeta != null) {
            confirmMeta.setDisplayName(data.isComplete() ? ChatColor.GREEN + "Confirm Creation" : ChatColor.GRAY + "Confirm Creation");
            List<String> confirmLore = new ArrayList<>();
            if (data.isComplete()) {
                confirmLore.add(ChatColor.YELLOW + "Click to create this tag!");
            } else {
                confirmLore.add(ChatColor.RED + "Please set Name, Display,");
                confirmLore.add(ChatColor.RED + "and Weight first.");
            }
            confirmMeta.setLore(confirmLore);
            confirmItem.setItemMeta(confirmMeta);
        }
        wizardMenu.setItem(35, confirmItem);


        player.openInventory(wizardMenu);
    }



    // Opens a confirmation menu for purging data
    public void openPurgeConfirmationMenu(Player player, String purgeType) {


        if (!purgeType.equals("tags") && !purgeType.equals("requests")) {
            player.sendMessage(ChatColor.RED + "Invalid purge type specified for confirmation menu.");
            return;
        }

        Inventory confirmMenu = Bukkit.createInventory(player, 9, ChatColor.DARK_RED + "Confirm Purge: " + purgeType);

        // Confirmation Item (e.g., Red Wool)
        ItemStack confirmItem = new ItemStack(Material.RED_WOOL);
        ItemMeta confirmMeta = confirmItem.getItemMeta();
        if (confirmMeta != null) {
            confirmMeta.setDisplayName(ChatColor.RED + "" + ChatColor.BOLD + "CONFIRM PURGE " + purgeType.toUpperCase());
            confirmMeta.setLore(Arrays.asList(
                    ChatColor.YELLOW + "Click to permanently delete all " + purgeType + ".",
                    ChatColor.DARK_RED + "This action cannot be undone!"
            ));
            // Store purge type in PDC for listener
            // TODO: Implement PDC
            // confirmMeta.getPersistentDataContainer().set(new NamespacedKey(plugin, "utag_purge_type"), PersistentDataType.STRING, purgeType);
            confirmItem.setItemMeta(confirmMeta);
        }

        // Cancel Item (e.g., Green Wool)
        ItemStack cancelItem = new ItemStack(Material.GREEN_WOOL);
        ItemMeta cancelMeta = cancelItem.getItemMeta();
        if (cancelMeta != null) {
            cancelMeta.setDisplayName(ChatColor.GREEN + "Cancel");
            cancelMeta.setLore(Arrays.asList(ChatColor.GRAY + "Return to the admin menu."));
            cancelItem.setItemMeta(cancelMeta);
        }

        // Layout: [X] [X] [C] [X] [X] [X] [A] [X] [X] (C=Confirm, A=Cancel)
        confirmMenu.setItem(2, confirmItem);
        confirmMenu.setItem(6, cancelItem);

        player.openInventory(confirmMenu);
    }

    // TODO: Implement openCreateTagWizard(Player player, ...)
    // TODO: Implement openPurgeTypeSelectionMenu(Player player)

}
</file>

<file path="src/main/java/com/blockworlds/utags/ChangeNameColorCommand.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

public class ChangeNameColorCommand implements CommandExecutor {

    private final uTags plugin;
    private final NameColorMenuManager nameColorMenuManager;

    public ChangeNameColorCommand(uTags plugin, NameColorMenuManager nameColorMenuManager) {
        this.plugin = plugin;
        this.nameColorMenuManager = nameColorMenuManager;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage(ChatColor.RED + "This command can only be used by players.");
            return true;
        }

        Player player = (Player) sender;

        // Permission Check
        if (!player.hasPermission("utags.changenamecolor")) {
            player.sendMessage(ChatColor.RED + "You do not have permission to change your name color.");
            return true;
        }

        // Open the name color selection menu
        nameColorMenuManager.openNameColorMenu(player);
        return true;
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/LuckPermsListener.java">
package com.blockworlds.utags;

import net.luckperms.api.LuckPerms;
import net.luckperms.api.event.EventBus;
import net.luckperms.api.event.user.UserDataRecalculateEvent;
import net.luckperms.api.model.user.User;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;

public class LuckPermsListener {

    private final uTags plugin;

    public LuckPermsListener(uTags plugin, LuckPerms luckPerms) {
        this.plugin = plugin;
        // Register the listener with LuckPerms' event bus
        EventBus eventBus = luckPerms.getEventBus();
        eventBus.subscribe(this.plugin, UserDataRecalculateEvent.class, this::onUserDataRecalculate);
        plugin.getLogger().info("Registered LuckPerms UserDataRecalculateEvent listener.");
    }

    private void onUserDataRecalculate(UserDataRecalculateEvent event) {
        User user = event.getUser();
        // Try to get the Bukkit player associated with this user
        Player player = Bukkit.getPlayer(user.getUniqueId());

        // Check if the player is online on this server instance
        if (player != null && player.isOnline()) {
             // --- LISTENER DEBUG LOGGING ---
             // Get metadata DIRECTLY from the user object provided by the event
             String eventPrefix = user.getCachedData().getMetaData().getPrefix();
             String eventSuffix = user.getCachedData().getMetaData().getSuffix();
             plugin.getLogger().info("[LISTENER DEBUG] UserDataRecalculateEvent for " + player.getName() + ". Prefix: '" + eventPrefix + "', Suffix: '" + eventSuffix + "'. Scheduling refresh.");
             // --- END LISTENER DEBUG LOGGING ---

            // Schedule the display name refresh to run on the main server thread
            // No delay needed here, as the event signifies data is ready
            Bukkit.getScheduler().runTask(plugin, () -> {
                // Pass null for the prefix; the refresh method will fetch the latest from cache
                plugin.refreshBukkitDisplayName(player);
            });
        } else {
             plugin.getLogger().finest("LuckPerms UserDataRecalculateEvent detected for offline/unknown user: " + user.getUniqueId());
        }
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/NameColorMenuListener.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.Map;

public class NameColorMenuListener implements Listener {

    private final uTags plugin;

    // Reverted constructor to match usage in uTags.java
    public NameColorMenuListener(uTags plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player)) {
            return;
        }

        Player player = (Player) event.getWhoClicked();
        Inventory clickedInventory = event.getClickedInventory();
        ItemStack clickedItem = event.getCurrentItem();

        // Check if the clicked inventory is the Name Color Menu
        if (clickedInventory != null && event.getView().getTitle().equals(NameColorMenuManager.MENU_TITLE)) {
            // Prevent taking items from the menu
            event.setCancelled(true);

            if (clickedItem == null || clickedItem.getType() == Material.AIR || !clickedItem.hasItemMeta()) {
                return; // Ignore clicks on empty slots or items without meta
            }

            ItemMeta meta = clickedItem.getItemMeta();
            if (meta == null || !meta.hasDisplayName()) {
                return; // Ignore items without a display name
            }

            String displayName = meta.getDisplayName();
            String strippedName = ChatColor.stripColor(displayName); // Get the plain color name (e.g., "Light Blue")
            String colorCode = findColorCodeByName(strippedName);

            if (colorCode == null) {
                player.sendMessage(ChatColor.RED + "Could not determine the color code for the selected item.");
                plugin.getLogger().warning("Could not find color code for item display name: " + displayName + " (Stripped: " + strippedName + ")");
                return;
            }

            // Permission check (redundant if menu only shows permitted items, but good practice)
            String permissionNode = "utags.namecolor." + strippedName.toLowerCase().replace(" ", "_");
            if (!player.hasPermission(permissionNode)) {
                player.sendMessage(ChatColor.RED + "You do not have permission to use this name color.");
                return;
            }

            // Update player's preference and display name
            plugin.savePlayerNameColorCode(player.getUniqueId(), colorCode); // Persist preference
            plugin.updatePlayerDisplayName(player); // Apply change immediately

            player.sendMessage(ChatColor.GREEN + "Your name color has been updated to " + ChatColor.translateAlternateColorCodes('&', colorCode) + strippedName + ChatColor.GREEN + "!");
            player.closeInventory();
        }
    }

    /**
     * Finds the color code (&a, &c, etc.) based on the friendly color name.
     * This requires looking up the name in the config again.
     *
     * @param colorName The friendly name of the color (e.g., "Light Blue")
     * @return The color code (e.g., "&b") or null if not found.
     */
    private String findColorCodeByName(String colorName) {
        org.bukkit.configuration.ConfigurationSection nameColorSection = plugin.getConfig().getConfigurationSection("name-colors");
        if (nameColorSection == null) {
            return null;
        }

        for (String key : nameColorSection.getKeys(false)) {
            // Compare the config key (which should ideally match the friendly name)
            if (key.equalsIgnoreCase(colorName)) {
                return nameColorSection.getString(key);
            }
        }
        // Fallback: Check if the value matches the stripped name (less ideal)
         for (String key : nameColorSection.getKeys(false)) {
             String code = nameColorSection.getString(key);
             ChatColor chatColor = ChatColor.getByChar(code.replace("&", ""));
             if (chatColor != null && chatColor.name().replace("_", " ").equalsIgnoreCase(colorName)) {
                 return code;
             }
         }

        return null; // Not found
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/NameColorMenuManager.java">
package com.blockworlds.utags;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

public class NameColorMenuManager {

    private final uTags plugin;
    public static final String MENU_TITLE = ChatColor.DARK_AQUA + "Select Name Color";

    public NameColorMenuManager(uTags plugin) {
        this.plugin = plugin;
    }

    public void openNameColorMenu(Player player) {
        org.bukkit.configuration.ConfigurationSection nameColorSection = plugin.getConfig().getConfigurationSection("name-colors");

        if (nameColorSection == null || nameColorSection.getKeys(false).isEmpty()) {
            player.sendMessage(ChatColor.RED + "Name colors are not configured or enabled in config.yml.");
            return;
        }

        Map<String, String> availableColors = new HashMap<>();
        for (String key : nameColorSection.getKeys(false)) {
            String value = nameColorSection.getString(key);
            if (value != null && !value.isEmpty()) {
                 availableColors.put(key, value);
            } else {
                plugin.getLogger().warning("Invalid or empty value for name color key: " + key);
            }
        }

        if (availableColors.isEmpty()) {
             player.sendMessage(ChatColor.RED + "No valid name colors found in the configuration.");
             return;
        }

        int size = (int) Math.ceil(availableColors.size() / 9.0) * 9;
        size = Math.max(9, Math.min(size, 54)); // Ensure size is between 9 and 54
        Inventory menu = Bukkit.createInventory(null, size, MENU_TITLE);

        int slot = 0;
        for (Map.Entry<String, String> entry : availableColors.entrySet()) {
            String colorName = entry.getKey();
            String colorCode = entry.getValue();
            ChatColor chatColor = ChatColor.getByChar(colorCode.replace("&", ""));

            if (chatColor == null) {
                plugin.getLogger().warning("Invalid color code found in config for name color '" + colorName + "': " + colorCode);
                continue; // Skip invalid colors
            }

            // Basic permission check (can be expanded)
            if (!player.hasPermission("utags.namecolor." + colorName.toLowerCase().replace(" ", "_"))) {
                 continue; // Skip colors the player doesn't have permission for
            }

            ItemStack item = createColorItem(chatColor, colorName);
            menu.setItem(slot++, item);

            if (slot >= size) {
                plugin.getLogger().warning("Too many name colors defined to fit in the menu. Some colors might not be displayed.");
                break; // Stop if menu is full
            }
        }

        if (menu.firstEmpty() == -1 && slot < availableColors.size()) {
             plugin.getLogger().warning("Name color menu is full, but more colors were available. Consider increasing menu size or reducing colors.");
        } else if (slot == 0) {
            player.sendMessage(ChatColor.RED + "You do not have permission to use any name colors, or none are configured.");
            return; // Don't open an empty menu
        }


        player.openInventory(menu);
    }

    private ItemStack createColorItem(ChatColor color, String colorName) {
        Material material = getMaterialForColor(color); // Get appropriate material (e.g., colored wool)
        ItemStack item = new ItemStack(material, 1);
        ItemMeta meta = item.getItemMeta();

        if (meta != null) {
            meta.setDisplayName(color + colorName);
            List<String> lore = new ArrayList<>();
            lore.add(ChatColor.GRAY + "Click to select this name color.");
            // Add permission info if needed: lore.add(ChatColor.DARK_GRAY + "Requires: utags.namecolor." + colorName.toLowerCase().replace(" ", "_"));
            meta.setLore(lore);
            item.setItemMeta(meta);
        }
        return item;
    }

    // Helper to get a representative material for the color
    private Material getMaterialForColor(ChatColor color) {
        switch (color) {
            case BLACK: return Material.BLACK_WOOL;
            case DARK_BLUE: return Material.BLUE_WOOL;
            case DARK_GREEN: return Material.GREEN_WOOL;
            case DARK_AQUA: return Material.CYAN_WOOL;
            case DARK_RED: return Material.RED_WOOL;
            case DARK_PURPLE: return Material.PURPLE_WOOL;
            case GOLD: return Material.ORANGE_WOOL; // Often represented by Orange
            case GRAY: return Material.LIGHT_GRAY_WOOL;
            case DARK_GRAY: return Material.GRAY_WOOL;
            case BLUE: return Material.LIGHT_BLUE_WOOL;
            case GREEN: return Material.LIME_WOOL;
            case AQUA: return Material.LIGHT_BLUE_WOOL; // Often represented by Light Blue
            case RED: return Material.PINK_WOOL; // Often represented by Pink or Red
            case LIGHT_PURPLE: return Material.MAGENTA_WOOL;
            case YELLOW: return Material.YELLOW_WOOL;
            case WHITE: return Material.WHITE_WOOL;
            default: return Material.WHITE_WOOL; // Default fallback
        }
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/NameCommand.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

// Renamed class
public class NameCommand implements CommandExecutor {

    private final uTags plugin;
    private final NameColorMenuManager nameColorMenuManager;

    // Renamed constructor
    public NameCommand(uTags plugin, NameColorMenuManager nameColorMenuManager) {
        this.plugin = plugin;
        this.nameColorMenuManager = nameColorMenuManager;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage(ChatColor.RED + "This command can only be used by players.");
            return true;
        }

        Player player = (Player) sender;

        // Updated Permission Check
        if (!player.hasPermission("utags.name.gui")) { // Changed permission node
            player.sendMessage(plugin.getMessage("no_permission")); // Use configurable message
            return true;
        }

        // Open the name color selection menu
        nameColorMenuManager.openNameColorMenu(player);
        return true;
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/PlayerTagColorPreference.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import java.util.UUID;

/**
 * Stores a player's custom color preferences for a specific tag.
 */
public class PlayerTagColorPreference {

    // Fields for tag-specific colors (original purpose)
    private final UUID playerUuid;
    private final String tagName;
    private ChatColor bracketColor;
    private ChatColor contentColor;

    // Removed plugin field - logic moved to uTags.java

    /**
     * Constructor for PlayerTagColorPreference.
     * Initializes with default colors (null, indicating no override).
     *
     * @param playerUuid The UUID of the player.
     * @param tagName    The name of the tag being customized.
     */
    public PlayerTagColorPreference(UUID playerUuid, String tagName) {
        this.playerUuid = playerUuid;
        this.tagName = tagName;
        this.bracketColor = null; // Default: Use tag's original color
        this.contentColor = null; // Default: Use tag's original color
        // Removed leftover plugin initialization
    }

    /**
     * Constructor allowing initial color setting.
     *
     * @param playerUuid    The UUID of the player.
     * @param tagName       The name of the tag being customized.
     * @param bracketColor  The initial bracket color (can be null).
     * @param contentColor  The initial content color (can be null).
     */
    public PlayerTagColorPreference(UUID playerUuid, String tagName, ChatColor bracketColor, ChatColor contentColor) {
        this.playerUuid = playerUuid;
        this.tagName = tagName;
        this.bracketColor = bracketColor;
        this.contentColor = contentColor;
        // Removed plugin initialization
    }

    // Removed constructor specific to plugin injection

    public UUID getPlayerUuid() {
        return playerUuid;
    }

    public String getTagName() {
        return tagName;
    }

    public ChatColor getBracketColor() {
        return bracketColor;
    }

    public void setBracketColor(ChatColor bracketColor) {
        this.bracketColor = bracketColor;
    }

    public ChatColor getContentColor() {
        return contentColor;
    }

    // Removed setPlayerNameColor method - logic moved to uTags.java

    // Removed getPlayerNameColor method - logic moved to uTags.java



    public void setContentColor(ChatColor contentColor) {
        this.contentColor = contentColor;
    }

    /**
     * Checks if this preference object represents the default state (no custom colors).
     * @return true if both bracket and content colors are null, false otherwise.
     */
    public boolean isDefault() {
        return bracketColor == null && contentColor == null;
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagColorMenuListener.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

public class TagColorMenuListener implements Listener {

    private final uTags plugin;
    private final TagColorMenuManager colorMenuManager; // Keep a reference

    public TagColorMenuListener(uTags plugin, TagColorMenuManager colorMenuManager) {
        this.plugin = plugin;
        this.colorMenuManager = colorMenuManager;
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        // Basic checks
        if (!(event.getWhoClicked() instanceof Player)) return;
        Player player = (Player) event.getWhoClicked();
        Inventory clickedInventory = event.getClickedInventory();
        ItemStack clickedItem = event.getCurrentItem();
        String inventoryTitle = event.getView().getTitle();

        // Check if it's the color selection menu
        if (clickedInventory != null && inventoryTitle.startsWith(TagColorMenuManager.COLOR_MENU_TITLE)) {
            event.setCancelled(true); // Prevent taking items

            if (clickedItem == null || clickedItem.getType() == Material.AIR) {
                return; // Ignore clicks on empty slots
            }

            // Extract tag name from title
            String tagNamePart = inventoryTitle.substring(TagColorMenuManager.COLOR_MENU_TITLE.length());
            String tagName = null;
            if (tagNamePart.contains(" - ")) {
                 tagName = ChatColor.stripColor(tagNamePart.substring(tagNamePart.indexOf(" - ") + 3));
            }

            if (tagName == null) {
                player.sendMessage(ChatColor.RED + "Error identifying the tag being edited.");
                player.closeInventory();
                return;
            }

            // Validate Tag and Permissions
            Tag tag = plugin.getTagByName(tagName);
             if (tag == null) {
                 player.sendMessage(ChatColor.RED + "Could not find the tag: " + tagName);
                 player.closeInventory();
                 return;
             }
             if (!tag.isColor()) {
                 player.sendMessage(ChatColor.RED + "This tag does not support color customization.");
                 player.closeInventory();
                 return;
             }
             if (!player.hasPermission("utags.color")) {
                 player.sendMessage(ChatColor.RED + "You do not have permission to change tag colors.");
                 player.closeInventory();
                 return;
             }

            ItemMeta meta = clickedItem.getItemMeta();
            if (meta == null) return;
            String displayName = meta.getDisplayName();

            // --- Handle clicks on control items using else if ---

            // Mode Switch Click
            if (clickedItem.getType() == Material.INK_SAC || clickedItem.getType() == Material.BONE_MEAL) {
                boolean currentlyEditingBrackets = clickedItem.getType() == Material.INK_SAC;
                colorMenuManager.openColorSelectionMenu(player, tag, !currentlyEditingBrackets);
                return;
            }
            // Reset Click
            else if (clickedItem.getType() == Material.BARRIER && displayName.equals(TagColorMenuManager.RESET_ITEM_NAME)) {
                plugin.resetPlayerTagColor(player.getUniqueId(), tagName);
                player.sendMessage(ChatColor.GREEN + "Colors for tag '" + tagName + "' reset to default.");
                colorMenuManager.openColorSelectionMenu(player, tag, true); // Re-open menu
                return;
            }
            // Back Button Click
            else if (clickedItem.getType() == Material.ARROW && displayName.equals(TagColorMenuManager.BACK_BUTTON_NAME)) {
                plugin.getTagMenuManager().openTagSelection(player, 0, TagType.PREFIX); // Return to prefix menu
                return;
            }
            // Apply Button(s) Click
            else if (clickedItem.getType() == Material.LIME_WOOL || clickedItem.getType() == Material.YELLOW_WOOL) { // Check for both potential button materials
                PlayerTagColorPreference preference = plugin.getPlayerTagColorPreference(player.getUniqueId(), tagName);
                String finalDisplay = plugin.formatTagDisplayWithColor(tag.getDisplay(), preference);
                TagType applyType; // Determine which type to apply

                if (displayName.equals(TagColorMenuManager.APPLY_PREFIX_BUTTON_NAME)) {
                    applyType = TagType.PREFIX;
                } else if (displayName.equals(TagColorMenuManager.APPLY_SUFFIX_BUTTON_NAME)) {
                    applyType = TagType.SUFFIX;
                } else if (displayName.equals(TagColorMenuManager.ACCEPT_BUTTON_NAME)) {
                    // For non-BOTH tags, use the tag's original type
                    applyType = tag.getType();
                } else {
                    return; // Clicked on wool, but not a recognized apply button
                }

                // Pass the INTERNAL tag name, not the formatted display string.
                // setPlayerTag will handle formatting internally.
                plugin.setPlayerTag(player, tagName, applyType);
                player.closeInventory();
                player.sendMessage(ChatColor.GREEN + "Tag " + ChatColor.translateAlternateColorCodes('&', finalDisplay) + ChatColor.GREEN + " applied as " + applyType.name().toLowerCase() + " with custom colors!");
                return;
            }

            // --- Handle clicks on color panes (Only if no control button was clicked) ---
            ChatColor selectedColor = TagColorMenuManager.getChatColorFromItem(clickedItem);
            if (selectedColor != null) {
                // Determine which part is being edited
                ItemStack modeSwitchItem = clickedInventory.getItem(clickedInventory.getSize() - 2);
                boolean editingBrackets = modeSwitchItem != null && modeSwitchItem.getType() == Material.INK_SAC;

                PlayerTagColorPreference currentPref = plugin.getPlayerTagColorPreference(player.getUniqueId(), tagName);
                ChatColor newBracketColor = currentPref.getBracketColor();
                ChatColor newContentColor = currentPref.getContentColor();

                if (editingBrackets) {
                    newBracketColor = selectedColor;
                    player.sendMessage(ChatColor.GREEN + "Set bracket color to " + selectedColor + selectedColor.name());
                } else {
                    newContentColor = selectedColor;
                    player.sendMessage(ChatColor.GREEN + "Set content color to " + selectedColor + selectedColor.name());
                }

                plugin.setPlayerTagColor(player.getUniqueId(), tagName, newBracketColor, newContentColor);

                // Re-open the menu to reflect the change and show preview
                colorMenuManager.openColorSelectionMenu(player, tag, editingBrackets);
            }
            // Ignore clicks on other items like the preview item
        }
    }
} // End of class TagColorMenuListener
</file>

<file path="src/main/java/com/blockworlds/utags/TagColorMenuManager.java">
package com.blockworlds.utags;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class TagColorMenuManager {

    private final uTags plugin;
    public static final String COLOR_MENU_TITLE = ChatColor.BLUE + "Select Tag Color";
    public static final String BRACKET_MODE_LORE = ChatColor.YELLOW + "Click a color for the brackets []";
    public static final String CONTENT_MODE_LORE = ChatColor.YELLOW + "Click a color for the content";
    public static final String RESET_ITEM_NAME = ChatColor.RED + "Reset to Default Color";
    public static final String MODE_SWITCH_ITEM_NAME = ChatColor.AQUA + "Editing: "; // Append Bracket/Content
    public static final String BACK_BUTTON_NAME = ChatColor.GRAY + "Back";
    public static final String PREVIEW_ITEM_NAME = ChatColor.YELLOW + "Preview";
    public static final String ACCEPT_BUTTON_NAME = ChatColor.GREEN + "Apply Tag"; // Renamed for clarity
    public static final String APPLY_PREFIX_BUTTON_NAME = ChatColor.GREEN + "Apply as Prefix";
    public static final String APPLY_SUFFIX_BUTTON_NAME = ChatColor.YELLOW + "Apply as Suffix";

    // Map Bukkit Material (Stained Glass Pane) to ChatColor
    private static final List<Pair<Material, ChatColor>> COLOR_MAP = Arrays.asList(
            new Pair<>(Material.WHITE_STAINED_GLASS_PANE, ChatColor.WHITE),
            new Pair<>(Material.ORANGE_STAINED_GLASS_PANE, ChatColor.GOLD), // Bukkit Orange -> ChatColor Gold
            new Pair<>(Material.MAGENTA_STAINED_GLASS_PANE, ChatColor.LIGHT_PURPLE), // Bukkit Magenta -> ChatColor Light Purple
            new Pair<>(Material.LIGHT_BLUE_STAINED_GLASS_PANE, ChatColor.AQUA), // Bukkit Light Blue -> ChatColor Aqua
            new Pair<>(Material.YELLOW_STAINED_GLASS_PANE, ChatColor.YELLOW),
            new Pair<>(Material.LIME_STAINED_GLASS_PANE, ChatColor.GREEN), // Bukkit Lime -> ChatColor Green
            new Pair<>(Material.PINK_STAINED_GLASS_PANE, ChatColor.RED), // Bukkit Pink -> ChatColor Red (closest vibrant)
            new Pair<>(Material.GRAY_STAINED_GLASS_PANE, ChatColor.DARK_GRAY),
            new Pair<>(Material.LIGHT_GRAY_STAINED_GLASS_PANE, ChatColor.GRAY),
            new Pair<>(Material.CYAN_STAINED_GLASS_PANE, ChatColor.DARK_AQUA),
            new Pair<>(Material.PURPLE_STAINED_GLASS_PANE, ChatColor.DARK_PURPLE),
            new Pair<>(Material.BLUE_STAINED_GLASS_PANE, ChatColor.BLUE), // Bukkit Blue -> ChatColor Blue (Dark Blue is closer but less distinct)
            new Pair<>(Material.BROWN_STAINED_GLASS_PANE, ChatColor.DARK_RED), // Bukkit Brown -> ChatColor Dark Red (no direct brown)
            new Pair<>(Material.GREEN_STAINED_GLASS_PANE, ChatColor.DARK_GREEN),
            new Pair<>(Material.RED_STAINED_GLASS_PANE, ChatColor.DARK_RED), // Bukkit Red -> ChatColor Dark Red
            new Pair<>(Material.BLACK_STAINED_GLASS_PANE, ChatColor.BLACK)
    );

    public TagColorMenuManager(uTags plugin) {
        this.plugin = plugin;
    }

    /**
     * Opens the color selection GUI for a specific tag.
     *
     * @param player The player opening the menu.
     * @param tag    The tag being customized.
     * @param editingBrackets True if currently editing bracket color, false for content color.
     */
    public void openColorSelectionMenu(Player player, Tag tag, boolean editingBrackets) {
        // Calculate size needed (16 colors + mode switch + reset = 18 items -> 2 rows minimum)
        int size = 27; // 3 rows to be safe and allow spacing
        Inventory inv = Bukkit.createInventory(null, size, COLOR_MENU_TITLE + " - " + tag.getName());

        // Add color selection panes
        int slot = 0;
        for (Pair<Material, ChatColor> colorPair : COLOR_MAP) {
            if (slot >= size - 2) break; // Leave space for control items
            ItemStack glassPane = new ItemStack(colorPair.getKey());
            ItemMeta meta = glassPane.getItemMeta();
            if (meta != null) {
                meta.setDisplayName(colorPair.getValue() + colorPair.getValue().name().replace("_", " "));
                List<String> lore = new ArrayList<>();
                lore.add(editingBrackets ? BRACKET_MODE_LORE : CONTENT_MODE_LORE);
                meta.setLore(lore);
                glassPane.setItemMeta(meta);
            }
            inv.setItem(slot++, glassPane);
        }

        // Add Mode Switch Item (e.g., Ink Sac/Bone Meal)
        ItemStack modeSwitchItem = new ItemStack(editingBrackets ? Material.INK_SAC : Material.BONE_MEAL);
        ItemMeta modeMeta = modeSwitchItem.getItemMeta();
        if (modeMeta != null) {
            modeMeta.setDisplayName(MODE_SWITCH_ITEM_NAME + (editingBrackets ? ChatColor.GRAY + "Brackets []" : ChatColor.WHITE + "Content"));
            List<String> modeLore = new ArrayList<>();
            modeLore.add(ChatColor.GRAY + "Click to switch editing mode");
            modeLore.add(ChatColor.GRAY + "(Currently editing: " + (editingBrackets ? "Brackets" : "Content") + ")");
            // Add current colors for reference
            PlayerTagColorPreference currentPref = plugin.getPlayerTagColorPreference(player.getUniqueId(), tag.getName());
            ChatColor currentBracketColor = currentPref.getBracketColor();
            ChatColor currentContentColor = currentPref.getContentColor();
            modeLore.add("");
            modeLore.add(ChatColor.GRAY + "Current Bracket: " + (currentBracketColor != null ? currentBracketColor + "■" : "Default"));
            modeLore.add(ChatColor.GRAY + "Current Content: " + (currentContentColor != null ? currentContentColor + "■" : "Default"));

            modeMeta.setLore(modeLore);
            modeSwitchItem.setItemMeta(modeMeta);
        }
        inv.setItem(size - 2, modeSwitchItem); // Place towards the end

        // Add Reset Item (e.g., Barrier)
        ItemStack resetItem = new ItemStack(Material.BARRIER);
        ItemMeta resetMeta = resetItem.getItemMeta();
        if (resetMeta != null) {
            resetMeta.setDisplayName(RESET_ITEM_NAME);
            List<String> resetLore = new ArrayList<>();
            resetLore.add(ChatColor.GRAY + "Click to reset both colors");
            resetLore.add(ChatColor.GRAY + "to the tag's default.");
            resetMeta.setLore(resetLore);
            resetItem.setItemMeta(resetMeta);
        }
        inv.setItem(size - 1, resetItem); // Place at the very end

        // Add Back Button (Arrow)
        ItemStack backButton = new ItemStack(Material.ARROW);
        ItemMeta backMeta = backButton.getItemMeta();
        if (backMeta != null) {
            backMeta.setDisplayName(BACK_BUTTON_NAME);
            backMeta.setLore(Arrays.asList(ChatColor.GRAY + "Return to tag selection"));
            backButton.setItemMeta(backMeta);
        }
        inv.setItem(size - 9, backButton); // Bottom-left corner

        // Add Preview Item (Name Tag)
        ItemStack previewItem = new ItemStack(Material.NAME_TAG);
        ItemMeta previewMeta = previewItem.getItemMeta();
        if (previewMeta != null) {
            PlayerTagColorPreference currentPrefPreview = plugin.getPlayerTagColorPreference(player.getUniqueId(), tag.getName());
            String formattedPreview = plugin.formatTagDisplayWithColor(tag.getDisplay(), currentPrefPreview);
            previewMeta.setDisplayName(PREVIEW_ITEM_NAME + ": " + ChatColor.translateAlternateColorCodes('&', formattedPreview));
            List<String> previewLore = new ArrayList<>();
            previewLore.add(ChatColor.GRAY + "Current custom colors applied.");
            previewLore.add(" ");
            previewLore.add(ChatColor.YELLOW + "Default: " + ChatColor.translateAlternateColorCodes('&', tag.getDisplay())); // Show default
            previewMeta.setLore(previewLore);
            previewItem.setItemMeta(previewMeta);
        }
        // Add Apply Button(s)
        if (tag.getType() == TagType.BOTH) {
            // Add Apply as Prefix Button
            ItemStack applyPrefixButton = new ItemStack(Material.LIME_WOOL);
            ItemMeta prefixMeta = applyPrefixButton.getItemMeta();
            if (prefixMeta != null) {
                prefixMeta.setDisplayName(APPLY_PREFIX_BUTTON_NAME);
                prefixMeta.setLore(Arrays.asList(ChatColor.GRAY + "Apply as prefix with selected colors."));
                applyPrefixButton.setItemMeta(prefixMeta);
            }
            inv.setItem(size - 5, applyPrefixButton); // Place where preview was

            // Add Apply as Suffix Button
            ItemStack applySuffixButton = new ItemStack(Material.YELLOW_WOOL);
            ItemMeta suffixMeta = applySuffixButton.getItemMeta();
            if (suffixMeta != null) {
                suffixMeta.setDisplayName(APPLY_SUFFIX_BUTTON_NAME);
                suffixMeta.setLore(Arrays.asList(ChatColor.GRAY + "Apply as suffix with selected colors."));
                applySuffixButton.setItemMeta(suffixMeta);
            }
            inv.setItem(size - 4, applySuffixButton); // Place where accept was

            // Move Preview Item for BOTH tags
            inv.setItem(size - 6, previewItem); // Shift preview left

        } else {
            // Single Apply Button for PREFIX or SUFFIX tags
            ItemStack acceptButton = new ItemStack(Material.LIME_WOOL);
            ItemMeta acceptMeta = acceptButton.getItemMeta();
            if (acceptMeta != null) {
                acceptMeta.setDisplayName(ACCEPT_BUTTON_NAME); // Use the renamed constant
                acceptMeta.setLore(Arrays.asList(ChatColor.GRAY + "Apply this " + tag.getType().name().toLowerCase() + " with selected colors."));
                acceptButton.setItemMeta(acceptMeta);
            }
            inv.setItem(size - 4, acceptButton); // Original position
            inv.setItem(size - 5, previewItem); // Original preview position
        }

        player.openInventory(inv);
    }

    // Simple Pair class for mapping Material to ChatColor
    private static class Pair<K, V> {
        private final K key;
        private final V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }
    }

    /**
     * Gets the ChatColor associated with a clicked ItemStack (Stained Glass Pane).
     * @param item The ItemStack that was clicked.
     * @return The corresponding ChatColor, or null if not found.
     */
    public static ChatColor getChatColorFromItem(ItemStack item) {
        if (item == null || !item.getType().name().endsWith("_STAINED_GLASS_PANE")) {
            return null;
        }
        Material material = item.getType();
        for (Pair<Material, ChatColor> pair : COLOR_MAP) {
            if (pair.getKey() == material) {
                return pair.getValue();
            }
        }
        return null;
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagCreationData.java">
package com.blockworlds.utags;

import org.bukkit.inventory.ItemStack;
import org.bukkit.Material;

// Simple class to hold data during the tag creation wizard process
public class TagCreationData {
    private String name;
    private String display;
    private TagType type = TagType.PREFIX; // Default type
    private int weight = 10; // Default weight
    private ItemStack material = new ItemStack(Material.NAME_TAG); // Default icon
    private boolean isPublic = true; // Default public
    private boolean color = true; // Default color (though unused currently)

    // Getters
    public String getName() { return name; }
    public String getDisplay() { return display; }
    public TagType getType() { return type; }
    public int getWeight() { return weight; }
    public ItemStack getMaterial() { return material; }
    public boolean isPublic() { return isPublic; }
    public boolean isColor() { return color; }

    // Setters
    public void setName(String name) { this.name = name; }
    public void setDisplay(String display) { this.display = display; }
    public void setType(TagType type) { this.type = type; }
    public void setWeight(int weight) { this.weight = weight; }
    public void setMaterial(ItemStack material) { this.material = (material != null && material.getType() != Material.AIR) ? material : new ItemStack(Material.NAME_TAG); }
    public void setPublic(boolean isPublic) { this.isPublic = isPublic; }
    public void setColor(boolean color) { this.color = color; }

    // Check if essential data is set for final confirmation
    public boolean isComplete() {
        // Weight is now an int with a default, so no null check needed
        return name != null && !name.isEmpty() &&
               display != null && !display.isEmpty() &&
               type != null;
        // Material defaults, flags default
    }
}
</file>

<file path="README.md">
# uTags

A flexible prefix and suffix tag system for Minecraft Spigot servers.

## Features

*   Assign prefix and suffix tags to players.
*   Manage tags through commands and GUI menus (if applicable).
*   Customize player name colors independently from prefix tags.

## Important Change: Name Color Decoupling

Previously, selecting a prefix tag would also change the player's name color based on the tag's color. This behavior has been **removed**. Prefix tags now only display the tag itself, without affecting the player's name color.

To set your name color, please use the new `/tag namecolor` command detailed below.

## Commands

### Player Commands

*   **/tag list**: Displays available tags.
*   **/tag set <tag_name>**: Sets your active prefix tag.
*   **/tag clear**: Clears your active prefix tag.
*   **/tag namecolor <color_code|reset>**: Sets your display name color using standard Minecraft color codes (e.g., `&a`, `&b`, `&c`). Use `reset` to revert to the default color.
    *   *Example:* `/tag namecolor &a` (sets name color to light green)
    *   *Example:* `/tag namecolor reset` (resets name color)
*   **/tag request <tag_text>**: Requests a custom tag (requires admin approval).


### Name Color GUI

*   **/name**: Opens a GUI menu allowing you to select your desired name color from the pre-configured options.
*(Add other player commands if they exist)*

### Admin Commands

*(Add admin commands like /tag create, /tag delete, /tag approve, etc., if they exist)*

## Permissions

*   `utags.command.list`: Allows use of `/tag list`.
*   `utags.command.set`: Allows use of `/tag set`.
*   `utags.command.clear`: Allows use of `/tag clear`.
*   `utags.command.namecolor`: Allows use of `/tag namecolor`.
*   `utags.command.request`: Allows use of `/tag request`.
*   `utags.name.gui`: Allows use of `/name` and access to the name color GUI.
*   `utags.admin`: Grants access to all admin commands.

*(Add specific admin command permissions if they exist)*

## Configuration

*(Details about config.yml, including database credentials)*
### Name Colors
Database connection details (host, port, name, user, password) are also configured within `config.yml`.


The available colors for the `/changenamecolor` GUI are defined in `config.yml` under the `name-colors` section. You can customize the list of available colors there.

Example `config.yml` section:

```yaml
name-colors:
  - "&a" # Light Green
  - "&b" # Aqua
  - "&c" # Light Red
  - "&e" # Yellow
  # Add more color codes as needed
```


## Installation

1.  Place the `uTags.jar` file into your server's `plugins` folder.
2.  Restart or reload your server.
</file>

<file path="src/main/java/com/blockworlds/utags/CustomTagRequest.java">
package com.blockworlds.utags;

import java.util.UUID;

public class CustomTagRequest {
    private final int id;
    private final UUID playerUuid;
    private final String playerName;
    private final String tagDisplay;

    public CustomTagRequest(int id, UUID playerUuid, String playerName, String tagDisplay) {
        this.id = id;
        this.playerUuid = playerUuid;
        this.playerName = playerName;
        this.tagDisplay = tagDisplay;
    }

    public int getId() {
        return id;
    }

    public UUID getPlayerUuid() {
        return playerUuid;
    }

    public String getPlayerName() {
        return playerName;
    }

    public String getTagDisplay() {
        return tagDisplay;
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/LoginListener.java">
package com.blockworlds.utags;

import net.luckperms.api.model.user.User;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;

import java.util.UUID;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
public class LoginListener implements Listener {
    private uTags plugin;

    public LoginListener(uTags plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onPlayerJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();

        if (player.hasPermission("utags.staff")) {
            Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                if (plugin.hasPendingTagRequests()) {
                    player.sendMessage(ChatColor.RED + "There are pending tag requests. Use " + ChatColor.YELLOW + "/tag admin requests" + ChatColor.RED + " to check them.");
                }
            });
        }

        // Load player's custom tag color preferences
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            UUID playerUuid = player.getUniqueId();
            plugin.getLogger().fine("Loading tag color preferences for " + player.getName() + " (" + playerUuid + ")");
            String sql = "SELECT tag_name, bracket_color_code, content_color_code FROM player_tag_color_preferences WHERE player_uuid = ?";
            try (Connection conn = plugin.getConnection();
                 PreparedStatement ps = conn.prepareStatement(sql)) {

                ps.setString(1, playerUuid.toString());
                ResultSet rs = ps.executeQuery();

                int count = 0;
                while (rs.next()) {
                    String tagName = rs.getString("tag_name");
                    String bracketCode = rs.getString("bracket_color_code");
                    String contentCode = rs.getString("content_color_code");

                    ChatColor bracketColor = (bracketCode != null && bracketCode.length() == 2) ? ChatColor.getByChar(bracketCode.charAt(1)) : null;
                    ChatColor contentColor = (contentCode != null && contentCode.length() == 2) ? ChatColor.getByChar(contentCode.charAt(1)) : null;

                    // Use the existing method to populate the in-memory map
                    // Note: This will trigger another async save, which is redundant but harmless here.
                    // A better approach might be a dedicated loading method in uTags.
                    plugin.setPlayerTagColor(playerUuid, tagName, bracketColor, contentColor);
                    count++;
                }
                if (count > 0) {
                     plugin.getLogger().info("Loaded " + count + " tag color preferences for " + player.getName());
                }

            } catch (SQLException e) {
                plugin.getLogger().severe("Failed to load tag color preferences for " + player.getName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        });


        // Determine and store the applied prefix tag name on join
        UUID playerUuid = player.getUniqueId();
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            User user = plugin.getLuckPerms().getUserManager().getUser(playerUuid);
            if (user != null) {
                String currentPrefix = user.getCachedData().getMetaData().getPrefix();
                if (currentPrefix != null && currentPrefix.length() > 2) {
                    // Assume the last 2 chars are the color code added by this plugin
                    String potentialDisplay = currentPrefix.substring(0, currentPrefix.length() - 2);
                    // Check if this display string corresponds to a known tag
                    plugin.getTagNameByDisplayAsync(potentialDisplay).thenAcceptAsync(tagName -> {
                        if (tagName != null) {
                            // Store the mapping
                            plugin.playerAppliedPrefixTagName.put(playerUuid, tagName);
                            plugin.getLogger().info("Identified applied tag '" + tagName + "' for player " + player.getName() + " on join.");
                        } else {
                            // Prefix exists but doesn't match a known tag display (or tag was deleted)
                            // Remove any potentially stale mapping
                            plugin.playerAppliedPrefixTagName.remove(playerUuid);
                        }
                        // Update display name *after* potentially identifying the tag
                        Bukkit.getScheduler().runTask(plugin, () -> plugin.updatePlayerDisplayName(player));
                    }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable));
                } else {
                    // No prefix or prefix too short, remove any stale mapping and update display name
                    plugin.playerAppliedPrefixTagName.remove(playerUuid);
                    Bukkit.getScheduler().runTask(plugin, () -> plugin.updatePlayerDisplayName(player));
                }
            } else {
                 // Could not find LP user, just update display name
                 Bukkit.getScheduler().runTask(plugin, () -> plugin.updatePlayerDisplayName(player));
            }
        });
        

        if (player.hasPermission("utags.custom1") && !player.hasPermission("utags.tag." + player.getName() + "1")) {
            Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                if (plugin.hasPendingTagRequests()) {
                    player.sendMessage(ChatColor.GREEN + "You are able to request a custom tag! Use " + ChatColor.YELLOW + "/tag request" + ChatColor.GREEN + " to request your tag.");
                }
            });
        }
        if (player.hasPermission("utags.custom2") && !player.hasPermission("utags.tag." + player.getName() + "2")) {
            Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                if (plugin.hasPendingTagRequests()) {
                    player.sendMessage(ChatColor.GREEN + "You are able to request a custom tag! Use " + ChatColor.YELLOW + "/tag request" + ChatColor.GREEN + " to request your tag.");
                }
            });
        }
        if (player.hasPermission("utags.custom3") && !player.hasPermission("utags.tag." + player.getName() + "3")) {
            Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                if (plugin.hasPendingTagRequests()) {
                    player.sendMessage(ChatColor.GREEN + "You are able to request a custom tag! Use " + ChatColor.YELLOW + "/tag request" + ChatColor.GREEN + " to request your tag.");
                }
            });
        }
        if (player.hasPermission("utags.custom4") && !player.hasPermission("utags.tag." + player.getName() + "4")) {
            Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                if (plugin.hasPendingTagRequests()) {
                    player.sendMessage(ChatColor.GREEN + "You are able to request a custom tag! Use " + ChatColor.YELLOW + "/tag request" + ChatColor.GREEN + " to request your tag.");
                }
            });
        }
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagCommandPreviewListener.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.AsyncPlayerChatEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class TagCommandPreviewListener implements Listener {
    private final uTags plugin;

    public TagCommandPreviewListener(uTags plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onClick(AsyncPlayerChatEvent event) {
        Player player = event.getPlayer();
        UUID playerId = player.getUniqueId();
        if (plugin.getPreviewTags().containsKey(playerId)) {
            event.setCancelled(true);
            String tag = plugin.getPreviewTags().get(playerId);

            if (event.getMessage().equalsIgnoreCase("accept")) {
                // Handle the tag request asynchronously
                plugin.createCustomTagRequestAsync(player, tag);
                // Feedback is handled within the async method
            } else if (event.getMessage().equalsIgnoreCase("decline")) {
                player.sendMessage(ChatColor.RED + "You have declined to request this tag. Please try again.");
            } else {
                player.sendMessage(ChatColor.RED + "Invalid Response. Please make a new tag request.");
            }
            plugin.getPreviewTags().remove(playerId);
        }
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagType.java">
package com.blockworlds.utags;

public enum TagType {
    PREFIX,
    SUFFIX,
    BOTH
}
</file>

<file path="src/main/resources/config.yml">
# uTags Plugin Configuration

# Default tag for new players
default-tag: "member"

# Database Configuration
database:
  host: "localhost"
  port: 3306
  database: "utags"
  username: "user"
  password: "password"
  schema: 2 # Note: Schema version might need updating if DB structure changed significantly

# --- GUI Configuration ---
frame-material: BLACK_STAINED_GLASS_PANE

# Note: Button slots below are currently hardcoded in listeners,
# these config values are not actively used yet.
previous-button:
  slot: 45
  material: ARROW
  display-name: '&bPrevious Page'
next-button:
  slot: 53
  material: ARROW
  display-name: '&bNext Page'
return-button:
  slot: 48 # Used for Switch Prefix/Suffix button in TagMenuManager
  material: BARRIER
  display-name: '&cReturn to Main Menu' # Not used, back button text is hardcoded
player-head-button:
  slot: 50 # Used for Remove Tag button in TagMenuManager
  display-name: '&aYour current tag' # Not used, player head text is hardcoded

# Lore for custom tag items in the /tag GUI
gui:
  custom-tag-items:
    # Item shown when player has the slot permission but not the specific tag permission
    unlocked-requestable:
      lore:
        - "&7You have unlocked this slot!"
        - "&7Click here or use &f/tag request <display>"
        - "&7to submit your custom tag."
    # Item shown when player has the specific tag permission (tag is set or available)
    # Placeholders: %display%, %internal_name%, %slot_number%
    unlocked-set:
      lore:
        - "&7Display: %display%"
        - " "
        - "&eClick to Select"
        - "&8ID: %internal_name%"
    # Item shown when player lacks the permission for the slot
    # Placeholders: %slot_number%
    locked:
      lore:
        - "&7Unlock this slot by ranking up"
        - "&7or visiting the server store."

# Command configuration for notifications (optional)
# accept-command: "mail send %player% Your custom tag request has been accepted!"
# deny-command: "mail send %player% Your custom tag request has been denied."

# --- Name Color Configuration ---
# Define available name colors and their corresponding permissions (utags.namecolor.<key>)
# Example: A player needs 'utags.namecolor.light_blue' to use the Light Blue color.
name-colors:
  Light Blue: "&b"
  Green: "&a"
  Red: "&c"
  Yellow: "&e"
  Gold: "&6"
  Aqua: "&b"
  Dark Aqua: "&3"
  Dark Blue: "&1"
  Dark Gray: "&8"
  Dark Green: "&2"
  Dark Purple: "&5"
  Dark Red: "&4"
  Gray: "&7"
  Light Purple: "&d"
  White: "&f"
  # Add more colors as needed


# --- Messages --- 
messages:
  no_permission: "&cYou do not have permission to use this command."
  namecolor_usage: "&cUsage: /tag namecolor <&code|reset>"
  namecolor_invalid_color: "&cInvalid color code. Use & followed by 0-9 or a-f, or use 'reset'."
  namecolor_reset_success: "&aYour name color has been reset to default."
  namecolor_success: "&aYour name color has been set to {color}&a."
</file>

<file path="src/main/resources/plugin.yml">
name: UTags
version: '${project.version}'
main: com.blockworlds.utags.uTags
api-version: 1.19
authors: [ Talabrek ]
description: Tags that players can display in chat
website: blockworlds.com

depend:
  - LuckPerms

commands:
  tag:
    description: Opens the tag menu or sends a custom tag request
    usage: /<command> [request] [tag]
    permission: utags.tag
    permission-message: You don't have permission to use this command.
  name: # Changed command name
    description: Opens the name color selection menu.
    usage: /<command>
    permission: utags.name.gui # Changed permission node
    permission-message: You don't have permission to change your name color.

permissions:
  utags.tag:
    description: Allows the player to use the /tag command
    default: true
  utags.tagcolor:
    description: Allows the player to change the color of their tag
    default: false
  utags.name.gui: # Changed permission node
    description: Allows the player to use the /name command to open the GUI.
    default: true # Or false, depending on desired default access
  utags.namecolor.*:
    description: Allows access to all defined name colors.
    default: op # Or false/true depending on desired default access
    children:
      utags.namecolor.light_blue: true
      utags.namecolor.green: true
      utags.namecolor.red: true
      utags.namecolor.yellow: true
      # Add children nodes for other colors defined in config.yml if needed for finer control,
      # otherwise utags.namecolor.* grants access to all configured colors.
      # Example:
      # utags.namecolor.gold: true
      # utags.namecolor.aqua: true
</file>

<file path="uTags.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule="true" type="JAVA_MODULE" version="4">
  <component name="FacetManager">
    <facet type="minecraft" name="Minecraft">
      <configuration>
        <autoDetectTypes>
          <platformType>SPIGOT</platformType>
        </autoDetectTypes>
      </configuration>
    </facet>
  </component>
  <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_1_8">
    <output url="file://$MODULE_DIR$/target/classes" />
    <output-test url="file://$MODULE_DIR$/target/test-classes" />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.spigotmc:spigot-api:1.19.4-R0.1-SNAPSHOT" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.guava:guava:31.1-jre" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.guava:failureaccess:1.0.1" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.code.findbugs:jsr305:3.0.2" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.checkerframework:checker-qual:3.12.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.errorprone:error_prone_annotations:2.11.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.j2objc:j2objc-annotations:1.3" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: com.google.code.gson:gson:2.10" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.joml:joml:1.10.5" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: net.md-5:bungeecord-chat:1.16-R0.4" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.yaml:snakeyaml:1.33" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: net.luckperms:api:5.4" level="project" />
  </component>
</module>
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.blockworlds</groupId>
    <artifactId>uTags</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>uTags</name>

    <description>Tags that players can display in chat</description>
    <properties>
        <java.version>1.8</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    <url>blockworlds.com</url>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.4.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                            <artifactSet>
                                <includes>
                                    <include>com.zaxxer:HikariCP</include>
                                </includes>
                            </artifactSet>
                            <relocations>
                                <relocation>
                                    <pattern>com.zaxxer.hikari</pattern>
                                    <shadedPattern>com.blockworlds.utags.libs.hikari</shadedPattern>
                                </relocation>
                            </relocations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>


        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>

    </build>

    <repositories>
        <repository>
            <id>spigotmc-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </repository>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </repository>
        <repository>
            <id>papermc-repo</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
    </repositories>

    <dependencies>
        <!-- Use Paper API instead of Spigot -->
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>1.19.4-R0.1-SNAPSHOT</version> <!-- Ensure this version exists in the repo -->
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>net.luckperms</groupId>
            <artifactId>api</artifactId>
            <version>5.4</version>
            <scope>provided</scope>
        </dependency>
    
        <!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.0.1</version>
        </dependency>

        <!-- Testing Dependencies Removed -->
    </dependencies>

    <pluginRepositories>
        <pluginRepository>
            <id>spigotmc-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </pluginRepository>
        <pluginRepository>
             <id>papermc-repo</id>
             <url>https://repo.papermc.io/repository/maven-public/</url>
        </pluginRepository>
         <pluginRepository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </pluginRepository>
    </pluginRepositories>
</project>
</file>

<file path="src/main/java/com/blockworlds/utags/RequestMenuClickListener.java">
package com.blockworlds.utags;

import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

public class RequestMenuClickListener implements Listener {

    private final uTags plugin;

    public RequestMenuClickListener(uTags plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        // Check if the clicker is a player
        if (!(event.getWhoClicked() instanceof Player)) {
            return;
        }
        
        Inventory inventory = event.getClickedInventory();
        Player player = (Player) event.getWhoClicked();

        if (inventory == null || !event.getView().getTitle().contains("Custom Tag Requests")) {
            return;
        }

        event.setCancelled(true);

        ItemStack clickedItem = event.getCurrentItem();
        if (clickedItem == null) {
            return;
        }

        String playerName = ChatColor.stripColor(clickedItem.getItemMeta().getDisplayName());
        CustomTagRequest request = plugin.getCustomTagRequestByPlayerName(playerName);

        if (request == null) {
            player.sendMessage(ChatColor.RED + "An error occurred. Please try again.");
            return;
        }

        if (event.isLeftClick()) {
            // Accept the custom tag request
            plugin.acceptCustomTagRequest(request);
            player.sendMessage(ChatColor.GREEN + "Custom tag request accepted.");

        } else if (event.isRightClick()) {
            // Deny the custom tag request
            plugin.denyCustomTagRequest(request);
            player.sendMessage(ChatColor.RED + "Custom tag request denied.");
        }

        // Update the requests menu
        plugin.openRequestsMenu(player);
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/Tag.java">
package com.blockworlds.utags;

import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

public class Tag {

    private String name;
    private String display;
    private TagType type;
    private boolean isPublic;
    private boolean color;
    private int weight;

    private ItemStack material;

    public Tag(String name, String display, TagType type, boolean isPublic, boolean color, ItemStack material, int weight) {
        this.name = name;
        this.display = display;
        this.type = type;
        this.isPublic = isPublic;
        this.color = color;
        this.material = material;
        this.weight = weight;
    }

    public String getName() {
        return name;
    }

    public String getDisplay() {
        return display;
    }

    public TagType getType() {
        return type;
    }

    public boolean isPublic() {
        return isPublic;
    }

    public boolean isColor() {
        return color;
    }

    public ItemStack getMaterial() {
        return material;
    }

    public void setMaterial(ItemStack material) {
        this.material = material;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagMenuManager.java">
package com.blockworlds.utags;

import net.luckperms.api.model.user.User;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.SkullMeta;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class TagMenuManager {
    private final uTags plugin;

    public TagMenuManager(uTags plugin) {
        this.plugin = plugin;
    }

    // Original method - will be modified later to directly open selection
    public void openTagMenu(Player player) {
        // Redirect to openTagSelection directly for prefixes as default
        openTagSelection(player, 0, TagType.PREFIX);

        /* Old intermediate menu code:
        Inventory tagMenu = Bukkit.createInventory(player, 9,  "uTags Menu");

        ItemStack changePrefixItem = new ItemStack(Material.NAME_TAG);
        ItemMeta changePrefixMeta = changePrefixItem.getItemMeta();
        changePrefixMeta.setDisplayName(ChatColor.GREEN + "Change Prefix");
        changePrefixItem.setItemMeta(changePrefixMeta);

        ItemStack changeSuffixItem = new ItemStack(Material.NAME_TAG);
        ItemMeta changeSuffixMeta = changeSuffixItem.getItemMeta();
        changeSuffixMeta.setDisplayName(ChatColor.YELLOW + "Change Suffix");
        changeSuffixItem.setItemMeta(changeSuffixMeta);

        tagMenu.setItem(2, changePrefixItem);
        tagMenu.setItem(6, changeSuffixItem);

        // Add player's head to middle location
        addPlayerHead(player, tagMenu, 4); // Use the refactored method

        player.openInventory(tagMenu);
        */
    }

    // --- Methods moved from TagMenuListener ---

    public void openTagSelection(Player player, int pageIndex, TagType selectionType) {
        List<Tag> tags = plugin.getAvailableTags(selectionType);
        // Filter tags based on type (prefix/suffix/both)
        List<Tag> availableTags = tags.stream()
                .filter(tag -> tag.getType() == selectionType || tag.getType() == TagType.BOTH)
                .collect(Collectors.toList());

        // Filter tags based on permission/public status
        // Show tag if it's public OR player has specific permission
        List<Tag> permittedTags = availableTags.stream()
                .filter(tag -> tag.isPublic() || player.hasPermission("utags.tag." + tag.getName()))
                .collect(Collectors.toList());

        String inventoryTitle = selectionType == TagType.PREFIX ? "Select Prefix" : "Select Suffix";
        // Ensure title length doesn't exceed limits, add page number safely
        String fullTitle = inventoryTitle + " (Page " + (pageIndex + 1) + ")";
        if (fullTitle.length() > 32) {
            fullTitle = inventoryTitle.substring(0, Math.min(inventoryTitle.length(), 25)) + "... (P" + (pageIndex + 1) + ")";
        }

        Inventory inventory = createInventoryFrame(54, fullTitle,
                Material.valueOf(plugin.getConfig().getString("frame-material", "BLACK_STAINED_GLASS_PANE")), player);

        populateTagSelectionInventory(player, inventory, permittedTags, pageIndex, selectionType);

        // Add custom tag slots only for Prefix menu (top row)
        if (selectionType == TagType.PREFIX) {
            int[] itemSlots = {1, 3, 5, 7}; // Top row slots for custom tags
            for (int i = 0; i < itemSlots.length; i++) {
                // Only add if slot index is valid (e.g., 0-3 for 4 slots)
                ItemStack customTagItem = createCustomTagMenuItem(player, i);
                inventory.setItem(itemSlots[i], customTagItem);
            }
        }

        player.openInventory(inventory);
    }

    private void populateTagSelectionInventory(Player player, Inventory inventory, List<Tag> permittedTags, int pageIndex, TagType selectionType) {
        int itemsPerPage = 28; // 4 rows * 7 slots
        int startIndex = pageIndex * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, permittedTags.size());
        // Slots available for tags (excluding frame and navigation)
        int[] itemSlots = {10, 11, 12, 13, 14, 15, 16,
                           19, 20, 21, 22, 23, 24, 25,
                           28, 29, 30, 31, 32, 33, 34,
                           37, 38, 39, 40, 41, 42, 43};

        String currentTagDisplay = null;
        User user = plugin.getLuckPerms().getUserManager().getUser(player.getUniqueId());
        if (user != null) {
            currentTagDisplay = (selectionType == TagType.PREFIX) ?
                    user.getCachedData().getMetaData().getPrefix() :
                    user.getCachedData().getMetaData().getSuffix();
            // Normalize current tag display by removing color codes for comparison if needed
            // currentTagDisplay = currentTagDisplay != null ? ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&', currentTagDisplay)) : null;
        }


        int slotIndex = 0;
        for (int i = startIndex; i < endIndex; i++) {
            if (slotIndex >= itemSlots.length) break; // Safety check

            Tag tag = permittedTags.get(i);
            ItemStack tagItem = tag.getMaterial().clone(); // Clone to avoid modifying original
            ItemMeta tagMeta = tagItem.getItemMeta();

            if (tagMeta != null) {
                                // Get player preference and format display name
                PlayerTagColorPreference preference = plugin.getPlayerTagColorPreference(player.getUniqueId(), tag.getName());
                String formattedDisplay = plugin.formatTagDisplayWithColor(tag.getDisplay(), preference);
                String display = ChatColor.translateAlternateColorCodes('&', formattedDisplay);
                tagMeta.setDisplayName(display);

                List<String> lore = new ArrayList<>();
                // Example: Add existing lore if desired
                // if (tagMeta.hasLore()) {
                //     lore.addAll(tagMeta.getLore());
                // }
                lore.add(" "); // Spacer
                lore.add(ChatColor.YELLOW + "Click to Select");
                lore.add(ChatColor.DARK_GRAY + "ID: " + tag.getName()); // Use DARK_GRAY for internal info
                // Add default display to lore if different from current display
                String defaultDisplay = ChatColor.translateAlternateColorCodes('&', tag.getDisplay());
                if (!display.equals(defaultDisplay)) {
                    lore.add(ChatColor.YELLOW + "Default: " + defaultDisplay);
                }
                // Add color customization hint if applicable
                if (tag.isColor()) {
                    lore.add(ChatColor.AQUA + "Right-click to change color");
                }


                // TODO: Implement PersistentDataContainer to store internal name reliably
                // PersistentDataContainer pdc = tagMeta.getPersistentDataContainer();
                // pdc.set(new NamespacedKey(plugin, "utag_internal_name"), PersistentDataType.STRING, tag.getName());

                tagMeta.setLore(lore);


                // Add enchantment glow if this is the currently selected tag
                // Note: Comparing display names with color codes can be unreliable.
                // It's better to store/compare the internal name if possible.
                if (currentTagDisplay != null && currentTagDisplay.equals(tag.getDisplay())) { // Compare raw display string from DB
                   try {
                       tagItem.addUnsafeEnchantment(org.bukkit.enchantments.Enchantment.LURE, 1); // Use any enchantment
                       tagMeta.addItemFlags(org.bukkit.inventory.ItemFlag.HIDE_ENCHANTS);
                   } catch (Exception e) {
                       plugin.getLogger().warning("Failed to add enchantment glow: " + e.getMessage());
                   }
                }

                tagItem.setItemMeta(tagMeta); // Apply meta changes
            }

            inventory.setItem(itemSlots[slotIndex], tagItem);
            slotIndex++;
        }
        // Pass total count of permitted tags for accurate pagination
        addExtraMenuItems(player, inventory, pageIndex, permittedTags.size(), itemsPerPage, selectionType);
    }

    private void addExtraMenuItems(Player player, Inventory inventory, int pageIndex, int totalPermittedTags, int itemsPerPage, TagType currentType) {
        addPlayerHead(player, inventory, 49); // Player info always at bottom center

        // Previous Page Arrow
        if (pageIndex > 0) {
            ItemStack prevPageItem = createNavigationArrow(ChatColor.AQUA + "Previous Page");
            inventory.setItem(45, prevPageItem); // Bottom left
        }

        // Next Page Arrow
        // Check if there are more items than currently displayed up to this page
        if ((pageIndex + 1) * itemsPerPage < totalPermittedTags) {
            ItemStack nextPageItem = createNavigationArrow(ChatColor.AQUA + "Next Page");
            inventory.setItem(53, nextPageItem); // Bottom right
        }

        // Add Switch Button (Prefix/Suffix)
        ItemStack switchItem;
        ItemMeta switchMeta;
        if (currentType == TagType.PREFIX) {
            switchItem = new ItemStack(Material.NAME_TAG); // Consider different materials? Book?
            switchMeta = switchItem.getItemMeta();
            switchMeta.setDisplayName(ChatColor.YELLOW + "Switch to Suffixes");
            switchMeta.setLore(Arrays.asList(ChatColor.GRAY + "Click to view available suffixes."));
        } else {
            switchItem = new ItemStack(Material.NAME_TAG);
            switchMeta = switchItem.getItemMeta();
            switchMeta.setDisplayName(ChatColor.GREEN + "Switch to Prefixes");
            switchMeta.setLore(Arrays.asList(ChatColor.GRAY + "Click to view available prefixes."));
        }
        if (switchMeta != null) { // Null check
            switchItem.setItemMeta(switchMeta);
        }
        inventory.setItem(48, switchItem); // Slot next to player head (left)

        // Add Remove Tag Button
        ItemStack removeItem = new ItemStack(Material.BARRIER);
        ItemMeta removeMeta = removeItem.getItemMeta();
        if (removeMeta != null) { // Null check
            removeMeta.setDisplayName(ChatColor.RED + "Remove Current " + (currentType == TagType.PREFIX ? "Prefix" : "Suffix"));
            removeMeta.setLore(Arrays.asList(ChatColor.GRAY + "Click to remove your active tag."));
            removeItem.setItemMeta(removeMeta);
        }
        inventory.setItem(50, removeItem); // Slot next to player head (right)

        // Add Change Name Color Button
        ItemStack changeNameColorItem = new ItemStack(Material.EMERALD);
        ItemMeta changeNameColorMeta = changeNameColorItem.getItemMeta();
        if (changeNameColorMeta != null) {
            changeNameColorMeta.setDisplayName(ChatColor.LIGHT_PURPLE + "Change Name Color");
            changeNameColorMeta.setLore(Arrays.asList(ChatColor.GRAY + "Click to choose your name color."));
            changeNameColorItem.setItemMeta(changeNameColorMeta);
        }
        inventory.setItem(47, changeNameColorItem); // Slot next to switch button (left)
    }

    public void addPlayerHead(Player player, Inventory inventory, int location) {
        ItemStack playerHead = new ItemStack(Material.PLAYER_HEAD);
        SkullMeta playerHeadMeta = (SkullMeta) playerHead.getItemMeta();
        if (playerHeadMeta == null) return; // Safety check

        playerHeadMeta.setOwningPlayer(player);
        playerHeadMeta.setDisplayName(ChatColor.YELLOW + player.getName());

        String prefix = null;
        String suffix = null;
        User user = plugin.getLuckPerms().getUserManager().getUser(player.getUniqueId());
        if (user != null) {
            prefix = user.getCachedData().getMetaData().getPrefix();
            suffix = user.getCachedData().getMetaData().getSuffix();
        }

        List<String> lore = new ArrayList<>();
        lore.add(ChatColor.GRAY + "--- Current Tags ---");
        if (prefix != null && !prefix.isEmpty()) {
            lore.add(ChatColor.GRAY + "Prefix: " + ChatColor.translateAlternateColorCodes('&', prefix));
        } else {
            lore.add(ChatColor.GRAY + "Prefix: " + ChatColor.ITALIC + "None");
        }
        if (suffix != null && !suffix.isEmpty()) {
            lore.add(ChatColor.GRAY + "Suffix: " + ChatColor.translateAlternateColorCodes('&', suffix));
        } else {
            lore.add(ChatColor.GRAY + "Suffix: " + ChatColor.ITALIC + "None");
        }

        playerHeadMeta.setLore(lore);
        playerHead.setItemMeta(playerHeadMeta);
        inventory.setItem(location, playerHead);
    }

    private ItemStack createNavigationArrow(String displayName) {
        ItemStack arrowItem = new ItemStack(Material.ARROW);
        ItemMeta arrowMeta = arrowItem.getItemMeta();
        if (arrowMeta == null) return arrowItem; // Safety check
        arrowMeta.setDisplayName(displayName);
        arrowItem.setItemMeta(arrowMeta);
        return arrowItem;
    }

    public Inventory createInventoryFrame(int size, String title, Material frameMaterial, Player player) {
        // Ensure size is valid
        if (size <= 0 || size % 9 != 0) {
            size = 54; // Default to max size if invalid
        }
        // Ensure title is not too long
        if (title.length() > 32) {
            title = title.substring(0, 32);
        }
        Inventory inventory = Bukkit.createInventory(player, size, title);

        ItemStack frameItem = new ItemStack(frameMaterial);
        ItemMeta frameMeta = frameItem.getItemMeta();
        if (frameMeta != null) {
            frameMeta.setDisplayName(" ");
            frameItem.setItemMeta(frameMeta);
        }

        // Fill the border slots
        for (int i = 0; i < size; i++) {
            // Check if it's a border slot
            if (i < 9 || i >= size - 9 || i % 9 == 0 || (i + 1) % 9 == 0) {
                inventory.setItem(i, frameItem.clone()); // Use clone to avoid issues
            }
        }

        return inventory;
    }

    private ItemStack createCustomTagMenuItem(Player player, int slotIndex) {
        // slotIndex is 0-based (0, 1, 2, 3 for 4 slots)
        String permissionBase = "utags.custom"; // e.g., utags.custom1, utags.custom2
        String permissionTagBase = "utags.tag." + player.getName(); // e.g., utags.tag.PlayerName1
        ItemStack item;
        ItemMeta meta;

        String customTagPermission = permissionTagBase + (slotIndex + 1); // Permission for the specific tag
        String customSlotPermission = permissionBase + (slotIndex + 1); // Permission for the slot itself

        if (player.hasPermission(customTagPermission)) {
            // Player has the specific custom tag unlocked (implies they also have the slot permission)
            item = new ItemStack(Material.PLAYER_HEAD, 1);
            SkullMeta skullMeta = (SkullMeta) item.getItemMeta();
            if (skullMeta != null) {
                 skullMeta.setOwningPlayer(player); // Show player's head
                 meta = skullMeta;

                 String tagInternalName = player.getName() + (slotIndex + 1);
                 String tagDisplay = plugin.getTagDisplayByName(tagInternalName);
                 if (tagDisplay == null) {
                     // This case might mean the tag was granted but somehow removed from DB? Or name mismatch.
                     tagDisplay = ChatColor.RED + "" + ChatColor.ITALIC + "Error: Not Found";
                 } else {
                     tagDisplay = ChatColor.translateAlternateColorCodes('&', tagDisplay);
                 }

                 meta.setDisplayName(ChatColor.GOLD + "Custom Tag #" + (slotIndex + 1));
                 // Configurable Lore for Unlocked/Set Tags
                 List<String> configLoreSet = plugin.getConfig().getStringList("gui.custom-tag-items.unlocked-set.lore");
                 List<String> finalLoreSet = new ArrayList<>();
                 for (String line : configLoreSet) {
                     finalLoreSet.add(ChatColor.translateAlternateColorCodes('&', line
                             .replace("%display%", tagDisplay)
                             .replace("%internal_name%", tagInternalName)
                             .replace("%slot_number%", String.valueOf(slotIndex + 1))
                     ));
                 }
                 // Default lore if config is empty
                 if (finalLoreSet.isEmpty()) {
                     finalLoreSet.add(ChatColor.GRAY + "Display: " + tagDisplay);
                     finalLoreSet.add(" ");
                     finalLoreSet.add(ChatColor.YELLOW + "Click to Select");
                     finalLoreSet.add(ChatColor.DARK_GRAY + "ID: " + tagInternalName);
                 }
                 meta.setLore(finalLoreSet);


                 // TODO: Add PersistentDataContainer here too
                 // PersistentDataContainer pdc = meta.getPersistentDataContainer();
                 // pdc.set(new NamespacedKey(plugin, "utag_internal_name"), PersistentDataType.STRING, tagInternalName);

            } else {
                 // Fallback if SkullMeta fails
                 item = new ItemStack(Material.PAPER);
                 meta = item.getItemMeta();
                 meta.setDisplayName(ChatColor.GOLD + "Custom Tag #" + (slotIndex + 1));
            }

        } else if (player.hasPermission(customSlotPermission)) {
            // Player has the slot unlocked but hasn't requested/received the specific tag permission yet
            item = new ItemStack(Material.WRITABLE_BOOK, 1);
            meta = item.getItemMeta();
            meta.setDisplayName(ChatColor.YELLOW + "Request Custom Tag #" + (slotIndex + 1));
            // Configurable Lore for Requestable Slots
            List<String> configLoreReq = plugin.getConfig().getStringList("gui.custom-tag-items.unlocked-requestable.lore");
            List<String> finalLoreReq = new ArrayList<>();
            for (String line : configLoreReq) {
                finalLoreReq.add(ChatColor.translateAlternateColorCodes('&', line
                        .replace("%slot_number%", String.valueOf(slotIndex + 1))
                ));
            }
            // Default lore if config is empty
            if (finalLoreReq.isEmpty()) {
                finalLoreReq.add(ChatColor.GRAY + "You have unlocked this slot!");
                finalLoreReq.add(ChatColor.GRAY + "Click here or use " + ChatColor.WHITE + "/tag request <display>");
                finalLoreReq.add(ChatColor.GRAY + "to submit your custom tag.");
            }
            meta.setLore(finalLoreReq); // Use finalLoreReq here
        } else {
            // Player does not have permission for this slot
            item = new ItemStack(Material.BARRIER, 1);
            meta = item.getItemMeta();
            meta.setDisplayName(ChatColor.RED + "Locked Custom Tag #" + (slotIndex + 1));
            // Configurable Lore for Locked Slots
            List<String> configLoreLocked = plugin.getConfig().getStringList("gui.custom-tag-items.locked.lore");
            List<String> finalLoreLocked = new ArrayList<>();
            for (String line : configLoreLocked) {
                finalLoreLocked.add(ChatColor.translateAlternateColorCodes('&', line
                        .replace("%slot_number%", String.valueOf(slotIndex + 1))
                ));
            }
            // Default lore if config is empty
            if (finalLoreLocked.isEmpty()) {
                finalLoreLocked.add(ChatColor.GRAY + "Unlock this slot by ranking up");
                finalLoreLocked.add(ChatColor.GRAY + "or visiting the server store.");
            }
            meta.setLore(finalLoreLocked);
        } // End of the main if-else if-else structure

        if (meta != null) { // Ensure meta is not null before setting
             item.setItemMeta(meta);
        }
        return item;
    } // End of createCustomTagMenuItem



    // Method to open the custom tag request confirmation GUI
    public void openRequestConfirmation(Player player, String requestedTagDisplay) {
        // Simple 9-slot inventory for confirmation
        Inventory confirmationMenu = Bukkit.createInventory(player, 9, "Confirm Tag Request");

        // Item showing the tag preview
        ItemStack previewItem = new ItemStack(Material.PAPER); // Or NAME_TAG
        ItemMeta previewMeta = previewItem.getItemMeta();
        if (previewMeta != null) {
            previewMeta.setDisplayName(ChatColor.GOLD + "Preview:");
            previewMeta.setLore(Arrays.asList(
                    ChatColor.translateAlternateColorCodes('&', requestedTagDisplay),
                    " ",
                    ChatColor.GRAY + "Is this the tag you want to request?"
            ));
            // Store the requested tag display in the item's PDC for the listener
            // TODO: Implement PDC
            // previewMeta.getPersistentDataContainer().set(new NamespacedKey(plugin, "utag_request_display"), PersistentDataType.STRING, requestedTagDisplay);
            previewItem.setItemMeta(previewMeta);
        }

        // Confirm Button
        ItemStack confirmItem = new ItemStack(Material.GREEN_WOOL); // Or LIME_WOOL
        ItemMeta confirmMeta = confirmItem.getItemMeta();
        if (confirmMeta != null) {
            confirmMeta.setDisplayName(ChatColor.GREEN + "" + ChatColor.BOLD + "Confirm Request");
            confirmMeta.setLore(Arrays.asList(ChatColor.GRAY + "Submit this tag for review."));
            confirmItem.setItemMeta(confirmMeta);
        }

        // Cancel Button
        ItemStack cancelItem = new ItemStack(Material.RED_WOOL);
        ItemMeta cancelMeta = cancelItem.getItemMeta();
        if (cancelMeta != null) {
            cancelMeta.setDisplayName(ChatColor.RED + "" + ChatColor.BOLD + "Cancel");
            cancelMeta.setLore(Arrays.asList(ChatColor.GRAY + "Do not request this tag."));
            cancelItem.setItemMeta(cancelMeta);
        }

        // Layout: [C] [C] [C] [P] [X] [X] [X] [X] [X]
        // Example layout: Confirm at 2, Preview at 4, Cancel at 6
        confirmationMenu.setItem(2, confirmItem); // Confirm button
        confirmationMenu.setItem(4, previewItem);  // Preview in the middle
        confirmationMenu.setItem(6, cancelItem);  // Cancel button

        player.openInventory(confirmationMenu);
    }

    // --- End of moved methods ---
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagCommand.java">
package com.blockworlds.utags;

import org.bukkit.*;
import org.bukkit.command.*;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;

import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TagCommand implements CommandExecutor, TabCompleter {
    private static final int LINES_PER_PAGE = 50;
    private final uTags plugin;
    // Pattern to validate Minecraft color codes (&0-9, &a-f, case-insensitive)
    private static final Pattern COLOR_CODE_PATTERN = Pattern.compile("^&[0-9a-fA-F]$");

    public TagCommand(uTags plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("This command can only be used by players.");
            return true;
        }

        Player player = (Player) sender;

        if (args.length == 0) {
            // Directly open the prefix selection menu (page 0)
            plugin.getTagMenuManager().openTagSelection(player, 0, TagType.PREFIX);
            return true;
        }

        switch (args[0].toLowerCase()) {
            case "help":
                if (args.length == 1) {
                    displayHelp(player, 1);
                } else {
                    displayHelp(player, Integer.parseInt(args[1]));
                }
                break;

            case "set":
                if (args.length == 2) {
                    boolean hasPermission = player.hasPermission("utags.tag." + args[1]);
                    boolean isAvailableTag = plugin.getAvailableTags(TagType.PREFIX).stream().anyMatch(availableTag -> availableTag.getName().equals(args[1]));

                    if (!hasPermission || !isAvailableTag) {
                        player.sendMessage(ChatColor.RED + "You don't have permission to use this tag.");
                        return true;
                    }
                    plugin.setPlayerTag(player, plugin.getTagDisplayByName(args[1]), TagType.PREFIX);
                    player.sendMessage(ChatColor.GREEN + "Your " + TagType.PREFIX + " has been updated to: " + ChatColor.translateAlternateColorCodes('&', plugin.getTagDisplayByName(args[1])));
                } else {
                    player.sendMessage(ChatColor.RED + "Invalid usage. Use /tag help for a list of available commands.");
                }
                break;

            case "admin":
                handleAdminCommands(player, args);
                break;

            case "namecolor":
                handleNameColorCommand(player, args);
                break;

            case "request":
                if (args.length == 2) {
                    int customTagCount = plugin.countCustomTags(player.getName());
                    String requiredPermission = "utags.custom" + (customTagCount + 1);
                    plugin.getLogger().info("Checking required permission for request: " + requiredPermission);
                    if (player.hasPermission(requiredPermission)) {
                        String requestedTag = args[1];
                        String validationResult = isValidTag(requestedTag);
                        if (validationResult != null) {
                            player.sendMessage(ChatColor.RED + validationResult);
                            if (validationResult.contains("color code")) {
                                ChatColor[] colors = {ChatColor.BLACK, ChatColor.DARK_BLUE, ChatColor.DARK_GREEN, ChatColor.DARK_AQUA, ChatColor.DARK_RED, ChatColor.DARK_PURPLE, ChatColor.GOLD, ChatColor.GRAY, ChatColor.DARK_GRAY, ChatColor.BLUE, ChatColor.GREEN, ChatColor.AQUA, ChatColor.RED, ChatColor.LIGHT_PURPLE, ChatColor.YELLOW, ChatColor.WHITE};
                                String[] colorCodes = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
                                StringBuilder colorCodeList = new StringBuilder(ChatColor.AQUA + "List of available color codes: ");
                                for (int i = 0; i < colors.length; i++) {
                                    colorCodeList.append(colors[i]).append("&").append(colorCodes[i]).append(" ");
                                }
                                player.sendMessage(colorCodeList.toString().trim());
                            }
                            return true;
                        }
                        // Trim tag display after validation
                        int endIndex = requestedTag.indexOf(']') + 1;
                        if (endIndex > 0 && endIndex < requestedTag.length()) { // Ensure ']' exists and there's something after it
                            requestedTag = requestedTag.substring(0, endIndex);
                        }

                        // Open the GUI confirmation menu instead of chat prompt
                        plugin.getTagMenuManager().openRequestConfirmation(player, requestedTag);

                        // Remove old chat confirmation and preview listener logic
                        // player.sendMessage(ChatColor.GREEN + "Tag request preview: " + ChatColor.translateAlternateColorCodes('&', requestedTag));
                        // player.sendMessage(ChatColor.YELLOW + "Type 'accept' to accept the tag or 'decline' to try again.");
                        // plugin.addPreviewTag(player, requestedTag);

                        return true;
                    } else {
                        // TODO: Make permission denial message configurable
                        if (!requiredPermission.equalsIgnoreCase("utags.custom5")) // Example limit check
                            player.sendMessage(ChatColor.RED + "You can't request any more custom tags, unlock more custom tag slots every month as a premium subscriber.");
                        else
                            player.sendMessage(ChatColor.RED + "You have reached the maximum number of custom tags.");
                        return true;
                    }
                } else {
                    player.sendMessage(ChatColor.YELLOW + "Usage: /tag request [YourNewTag]");
                    player.sendMessage(ChatColor.YELLOW + "You must follow these rules when requesting a custom tag:");
                    player.sendMessage(ChatColor.YELLOW + "1. The tag must start with a color code.");
                    player.sendMessage(ChatColor.YELLOW + "2. The tag must be surrounded by square brackets ([ and ]).");
                    player.sendMessage(ChatColor.YELLOW + "3. The tag must be a maximum of 15 characters long.");
                    player.sendMessage(ChatColor.YELLOW + "4. The tag must not contain any spaces.");
                    player.sendMessage(ChatColor.YELLOW + "5. The tag must not contain any formatting codes (&k, &l, etc).");
                    player.sendMessage(ChatColor.YELLOW + "6. The tag must not contain any invalid characters.");
                    player.sendMessage(ChatColor.YELLOW + "7. Everything after the final square bracket will be ignored.");
                    player.sendMessage(ChatColor.YELLOW + "A staff member will review your request and approve it if it meets the requirements.");
                    ChatColor[] colors = {ChatColor.BLACK, ChatColor.DARK_BLUE, ChatColor.DARK_GREEN, ChatColor.DARK_AQUA, ChatColor.DARK_RED, ChatColor.DARK_PURPLE, ChatColor.GOLD, ChatColor.GRAY, ChatColor.DARK_GRAY, ChatColor.BLUE, ChatColor.GREEN, ChatColor.AQUA, ChatColor.RED, ChatColor.LIGHT_PURPLE, ChatColor.YELLOW, ChatColor.WHITE};
                    String[] colorCodes = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
                    StringBuilder colorCodeList = new StringBuilder(ChatColor.AQUA + "List of available color codes: ");
                    for (int i = 0; i < colors.length; i++) {
                        colorCodeList.append(colors[i]).append("&").append(colorCodes[i]).append(" ");
                    }
                    player.sendMessage(colorCodeList.toString().trim());
                }
                break;

            default:
                player.sendMessage(ChatColor.RED + "Invalid usage. Use /tag help for a list of available commands.");
                break;
        }
        return true;
    }

    private void displayHelp(Player player, int page) {
        List<String> helpLines = new ArrayList<>();

        helpLines.add(ChatColor.YELLOW + "Available commands:");

        // General help commands
        helpLines.add(ChatColor.GREEN + "/tag - Open the tag GUI menu.");
        helpLines.add(ChatColor.GREEN + "/tag set [tag] - Quick set a prefix tag.");
        helpLines.add(ChatColor.GREEN + "/tag namecolor <&code|reset> - Set your name color.");
        helpLines.add(ChatColor.GREEN + "/tag request [tag] - Request a custom tag. (Requires Veteran or Premium Membership)");

        // Add admin commands only if the player has the appropriate permission
        if (player.hasPermission("utags.admin")) {
            helpLines.add(ChatColor.YELLOW + "Admin commands:");
            helpLines.add(ChatColor.YELLOW + "/tag admin create [name] [display] [type] [weight] - Create a new tag.");
            helpLines.add(ChatColor.YELLOW + "/tag admin delete [name] - Delete an existing tag.");
            helpLines.add(ChatColor.YELLOW + "/tag admin edit [tagname] [attribute] [newvalue] - Edit an existing tag.");
            helpLines.add(ChatColor.YELLOW + "/tag admin requests - View pending custom tag requests.");
            helpLines.add(ChatColor.RED + "/tag admin purge tags - Purge all tags from the database.");
            helpLines.add(ChatColor.RED + "/tag admin purge requests - Purge all custom tag requests from the database.");
        }

        int linesPerPage = 50;
        int totalPages = (int) Math.ceil((double) helpLines.size() / linesPerPage);
        int startIndex = (page - 1) * linesPerPage;
        int endIndex = Math.min(helpLines.size(), startIndex + linesPerPage);

        if (page < 1 || page > totalPages) {
            player.sendMessage(ChatColor.RED + "Invalid page number.");
            return;
        }

        player.sendMessage(ChatColor.GOLD + "=== Help (Page " + page + " of " + totalPages + ") ===");
        for (int i = startIndex; i < endIndex; i++) {
            player.sendMessage(helpLines.get(i));
        }

        if (page < totalPages) {
            player.sendMessage(ChatColor.GOLD + "Type /tag help " + (page + 1) + " for the next page.");
        }
    }

    private void handleAdminCommands(Player player, String[] args) {
        if (!player.hasPermission("utags.admin")) {
            player.sendMessage(ChatColor.RED + "You do not have permission to use this command.");
            return;
        }

        if (args.length >= 2) {
            switch (args[1].toLowerCase()) {
                case "gui": // New case for the admin GUI
                    plugin.getAdminMenuManager().openAdminMainMenu(player);
                    break;
                case "create":
                    createTag(player, Arrays.copyOfRange(args, 2, args.length));
                    break;
                case "delete":
                    deleteTag(player, Arrays.copyOfRange(args, 2, args.length));
                    break;
                case "edit":
                    editTag(player, Arrays.copyOfRange(args, 2, args.length));
                    break;
                case "purge":
                    if (args.length == 3) {
                        // Send confirmation message
                        String purgeType = args[2].toLowerCase();
                        if (purgeType.equals("tags") || purgeType.equals("requests")) {
                            player.sendMessage(ChatColor.RED + "" + ChatColor.BOLD + "WARNING: " + ChatColor.YELLOW + "This action is irreversible!");
                            player.sendMessage(ChatColor.YELLOW + "To confirm purging all " + purgeType + ", type: " +
                                               ChatColor.WHITE + "/tag admin purge " + purgeType + " confirm");
                        } else {
                            player.sendMessage(ChatColor.RED + "Invalid purge type. Use 'tags' or 'requests'.");
                        }
                    } else if (args.length == 4 && args[3].equalsIgnoreCase("confirm")) {
                        // Execute purge on confirmation
                        String purgeType = args[2].toLowerCase();
                        switch (purgeType) {
                            case "tags":
                                plugin.purgeTagsTable();
                                player.sendMessage(ChatColor.RED + "All data has been purged from the tags table.");
                                break;
                            case "requests":
                                plugin.purgeRequestsTable();
                                player.sendMessage(ChatColor.RED + "All data has been purged from the requests table.");
                                break;
                            default:
                                player.sendMessage(ChatColor.RED + "Invalid purge type specified for confirmation.");
                        }
                    } else {
                        player.sendMessage(ChatColor.RED + "Usage: /tag admin purge <tags|requests> [confirm]");
                    }
                    break; // Added missing break statement
                case "requests":
                    plugin.openRequestsMenu(player);
                    break;
                default:
                    displayAdminUsage(player);
            }
        } else {
            displayAdminUsage(player);
        }
    }

    private void displayAdminUsage(Player player) {
        player.sendMessage(ChatColor.RED + "Usage: /tag admin create [name] [display] [type] [weight] [public(true/false)]");
        player.sendMessage(ChatColor.RED + "Usage: /tag admin delete [name]");
        player.sendMessage(ChatColor.RED + "Usage: /tag admin purge");
        player.sendMessage(ChatColor.RED + "Usage: /tag admin requests");
    }

    private void createTag(Player player, String[] args) {
        if (args.length != 5) { // Changed from 4 to 5
            player.sendMessage(ChatColor.RED + "Usage: /tag admin create [name] [display] [type] [weight] [public(true/false)]");
            return;
        }

        String name = args[0];
        String display = ChatColor.translateAlternateColorCodes('&', args[1]);
        String typeString = args[2].toUpperCase();
        int weight = Integer.parseInt(args[3]);
        boolean isPublic = Boolean.parseBoolean(args[4]); // New argument for public status
        ItemStack material = player.getInventory().getItemInMainHand();

        if (!name.matches("^[a-zA-Z0-9_-]+$")) {
            player.sendMessage(ChatColor.RED + "Invalid tag [name]. It should contain only letters, numbers, underscores, and hyphens.");
            return;
        }
        TagType type;
        try {
            type = TagType.valueOf(typeString);
        } catch (IllegalArgumentException e) {
            player.sendMessage(ChatColor.RED + "Invalid tag [type]. It should be one of 'PREFIX', 'SUFFIX', or 'BOTH'.");
            return;
        }


        if (weight < 0) {
            player.sendMessage(ChatColor.RED + "Invalid [weight] value. It should be a number greater than or equal to 0.");
            return;
        }

        // If the player is holding a player head, get the player head with custom texture
        if (material.getType() == Material.PLAYER_HEAD && material.getItemMeta() instanceof SkullMeta) {
            SkullMeta skullMeta = (SkullMeta) material.getItemMeta();
            if (skullMeta.hasOwner()) {
                material.setItemMeta(skullMeta);
            }
        }

        if (material.getType() == Material.AIR) {
            player.sendMessage(ChatColor.RED + "Invalid item for tag display. Hold an item in your hand.");
            return;
        }

        // Add the new tag to the database
        plugin.addTagToDatabase(new Tag(name, display, type, isPublic, Boolean.TRUE, material, weight)); // Use the isPublic variable

        player.sendMessage(ChatColor.GREEN + "Tag '" + name + "' - " + display + ChatColor.GREEN + " has been created.");
    }

    private void deleteTag(Player player, String[] args) {
        if (args.length != 1) {
            player.sendMessage(ChatColor.RED + "Usage: /tag admin delete [name]");
            return;
        }

        String name = args[0];

        // Delete the tag from the database
        plugin.deleteTagFromDatabase(name);

        player.sendMessage(ChatColor.RED + "Tag '" + name + "' " + ChatColor.RED + "has been deleted.");
    }

    private void editTag(CommandSender sender, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage(ChatColor.RED + "Only players can use this command.");
            return;
        }

        if (args.length < 4) {
            sender.sendMessage(ChatColor.RED + "Usage: /tag admin edit [tagname] [attribute] [newvalue]");
            return;
        }

        String tagName = args[1];
        String attribute = args[2];
        String newValue = args[3];

        if (!plugin.editTagAttribute(tagName, attribute, newValue)) {
            sender.sendMessage(ChatColor.RED + "Failed to edit the tag. Please check the tag name, attribute, and new value.");
            return;
        }

        sender.sendMessage(ChatColor.GREEN + "Successfully edited the tag.");
    }

    private boolean isValidBoolean(String value) {
        return "true".equalsIgnoreCase(value) || "false".equalsIgnoreCase(value);
    }

    private String isValidTag(String tag) {
        String colorCodePattern = "(&[0-9a-fA-F])";
        String invalidCodePattern = "(&[rRkKlLmMnNoO])";
        String tagPattern = "^" + colorCodePattern + "\\[" + "(?:(?:" + colorCodePattern + "|.)*){0,15}" + "\\]" + ".*" + "$";
        Pattern pattern = Pattern.compile(tagPattern);
        Matcher matcher = pattern.matcher(tag);

        if (!matcher.matches()) {
            return "A valid tag must start with a color code (e.g., &d, &6) followed by '[' and end with ']'.";
        }

        if (tag.matches(".*" + invalidCodePattern + ".*")) {
            return "A valid tag must not contain formatting codes such as &n or &k.";
        }

        String content = tag.substring(tag.indexOf('[') + 1, tag.length() - 1);
        String contentWithoutColorCodes = content.replaceAll(colorCodePattern, "");

        if (contentWithoutColorCodes.length() > 15) {
            return "A valid tag must be between 1 and 15 characters long, excluding color codes.";
        }

        return null; // No validation error
    }

    private void handleNameColorCommand(Player player, String[] args) {
        if (!player.hasPermission("utags.command.namecolor")) {
            player.sendMessage(plugin.getMessage("no_permission")); // Use configurable message
            return;
        }

        if (args.length != 2) {
            player.sendMessage(plugin.getMessage("namecolor_usage")); // Use configurable message
            return;
        }

        String colorInput = args[1];
        String finalColorCode = null; // Store the validated code or null for reset

        if ("reset".equalsIgnoreCase(colorInput)) {
            finalColorCode = null; // Resetting means setting to null
        } else {
            Matcher matcher = COLOR_CODE_PATTERN.matcher(colorInput);
            if (!matcher.matches()) {
                player.sendMessage(plugin.getMessage("namecolor_invalid_color")); // Use configurable message
                // Optionally list valid codes here if needed, similar to /tag request
                return;
            }
            finalColorCode = colorInput; // It's a valid color code
        }

        // Save the name color preference using the correct method in uTags.java
        plugin.savePlayerNameColorCode(player.getUniqueId(), finalColorCode);

        // Trigger display name update (assuming method exists in uTags)
        plugin.updatePlayerDisplayName(player); // Important: This needs implementation in uTags.java

        // Send confirmation message
        if (finalColorCode == null) {
            player.sendMessage(plugin.getMessage("namecolor_reset_success"));
        } else {
            // Use replace to show the color in the message
            player.sendMessage(plugin.getMessage("namecolor_success").replace("{color}", ChatColor.translateAlternateColorCodes('&', finalColorCode) + finalColorCode + ChatColor.GREEN));
        }
    }

    @Override
    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
        List<String> suggestions = new ArrayList<>();

        if (!(sender instanceof Player)) {
            return suggestions;
        }

        Player player = (Player) sender;

        if (args.length == 1) {
            suggestions.add("request");
            suggestions.add("set");
            if (player.hasPermission("utags.admin")) {
                suggestions.add("admin");
            }
            suggestions.add("namecolor"); // Add namecolor suggestion
        } else if (args.length == 2) {
            if ("set".equalsIgnoreCase(args[0])) {
                for (Tag tag : plugin.getAvailableTags(TagType.PREFIX)) {
                    if (player.hasPermission("utags.tag." + tag.getName())) {
                        suggestions.add(tag.getName());
                    }
                }
            } else if ("admin".equalsIgnoreCase(args[0])) {
                if (player.hasPermission("utags.admin")) {
                    suggestions.add("gui"); // Add gui suggestion
                    suggestions.add("create");
                    suggestions.add("delete");
                    suggestions.add("edit"); // Add missing edit suggestion
                    suggestions.add("requests"); // Add missing requests suggestion
                    suggestions.add("purge");
                }
            } else if ("namecolor".equalsIgnoreCase(args[0])) {
                if (player.hasPermission("utags.command.namecolor")) {
                    // Suggest color codes and reset
                    suggestions.addAll(Stream.of("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f")
                                            .map(code -> "&" + code)
                                            .collect(Collectors.toList()));
                    suggestions.add("reset");
                }
            }
        } else if (args.length >= 3 && "admin".equalsIgnoreCase(args[0])) {
            if (player.hasPermission("utags.admin")) {
                if ("create".equalsIgnoreCase(args[1])) {
                    if (args.length == 3) {
                        suggestions.add("TagName");
                    } else if (args.length == 4) {
                        suggestions.add("[TagDisplay]");
                    } else if (args.length == 5) {
                        suggestions.add("PREFIX");
                        suggestions.add("SUFFIX");
                        suggestions.add("BOTH");
                    } else if (args.length == 6) {
                        suggestions.add("[weight]");
                    } else if (args.length == 7) {
                        suggestions.add("true");
                        suggestions.add("false");
                    }
                } else if ("delete".equalsIgnoreCase(args[1])) {
                    // Suggest all tag names for deletion
                    plugin.getAvailableTags(null).stream() // Get all tags (prefix, suffix, both)
                          .map(Tag::getName)
                          .distinct() // Avoid duplicates if tag is 'both'
                          .forEach(suggestions::add);
                } else if ("purge".equalsIgnoreCase(args[1])) {
                    if (args.length == 3) {
                        suggestions.add("tags");
                        suggestions.add("requests");
                    } else if (args.length == 4 && (args[2].equalsIgnoreCase("tags") || args[2].equalsIgnoreCase("requests"))) {
                        suggestions.add("confirm");
                    }
                }
                // TODO: Add suggestions for 'edit' command
            }
        }

        // Filter suggestions based on current input
        String currentArg = args[args.length - 1].toLowerCase();
        return suggestions.stream()
                          .filter(s -> s.toLowerCase().startsWith(currentArg))
                          .collect(Collectors.toList());
    }
}
</file>

<file path="src/main/java/com/blockworlds/utags/TagMenuListener.java">
package com.blockworlds.utags;

import net.luckperms.api.model.user.User;
import net.luckperms.api.node.Node;
import net.luckperms.api.node.NodeType;
import net.luckperms.api.node.types.PrefixNode;
import net.luckperms.api.node.types.SuffixNode;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;


import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

public class TagMenuListener implements Listener {

    private final uTags plugin;
    // TODO: Uncomment and use PDC when ready
    // private final NamespacedKey tagInternalNameKey;

    public TagMenuListener(uTags plugin) {
        this.plugin = plugin;
        // this.tagInternalNameKey = new NamespacedKey(plugin, "utag_internal_name");
    }

    @EventHandler
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player)) {
            return;
        }

        Player player = (Player) event.getWhoClicked();
        ItemStack clickedItem = event.getCurrentItem();
        String inventoryTitle = event.getView().getTitle();

        // Basic checks
        if (!isUTagsMenu(inventoryTitle)) {
            return;
        }
        // Check raw slot against actual inventory size, prevent clicks outside
        if (event.getRawSlot() < 0 || event.getRawSlot() >= event.getInventory().getSize()) {
             return;
        }

        event.setCancelled(true); // Cancel all clicks in uTags menus

        if (clickedItem == null || clickedItem.getType() == Material.AIR || !clickedItem.hasItemMeta()) {
            return; // Ignore clicks on empty slots or items without meta
        }

        handleMenuInteraction(event, inventoryTitle);
    }

    private boolean isUTagsMenu(String inventoryTitle) {
        // Check if the title starts with the known prefixes
        // Check if the title starts with the known prefixes or is the confirmation menu
        return inventoryTitle.startsWith("uTags Menu")
                || inventoryTitle.startsWith("Select Prefix")
                || inventoryTitle.startsWith("Select Suffix")
                || inventoryTitle.equals("Confirm Tag Request"); // Add confirmation menu title
    }

    private void handleMenuInteraction(InventoryClickEvent event, String inventoryTitle) {
        if (inventoryTitle.startsWith("uTags Menu")) {
            handleOldTagMenuInteraction(event);
        } else if (inventoryTitle.startsWith("Select Prefix")) {
            handleTagSelection(event, TagType.PREFIX, parsePageIndex(inventoryTitle));
        } else if (inventoryTitle.startsWith("Select Suffix")) {
            handleTagSelection(event, TagType.SUFFIX, parsePageIndex(inventoryTitle));
        } else if (inventoryTitle.equals("Confirm Tag Request")) {
            handleRequestConfirmation(event); // Handle clicks in the confirmation menu
        }
    }

    // Extracts page index (0-based) from title like "Select Prefix (Page 1)"
    private int parsePageIndex(String title) {
        try {
            // Look for the pattern " (Page N)"
            String pageMarker = "(Page ";
            int pageStartIndex = title.lastIndexOf(pageMarker);
            if (pageStartIndex != -1) {
                // Find the closing parenthesis after the marker
                int pageEndIndex = title.indexOf(')', pageStartIndex + pageMarker.length());
                if (pageEndIndex != -1) {
                    // Extract the number string between "(Page " and ")"
                    String pageNumStr = title.substring(pageStartIndex + pageMarker.length(), pageEndIndex).trim();
                    return Integer.parseInt(pageNumStr) - 1; // Return 0-based index
                }
            }
            // If the standard format isn't found, log a warning and default to 0
            // Removed the unreliable legacy parsing attempt. Titles should consistently use "(Page N)".
            plugin.getLogger().warning("Could not find standard page format '(Page N)' in title: '" + title + "'. Defaulting to page 0.");
            return 0;

        } catch (NumberFormatException e) {
            plugin.getLogger().severe("Failed to parse page number from title: '" + title + "'. Found non-numeric content. Error: " + e.getMessage());
            return 0; // Default to page 0 on parsing error
        } catch (Exception e) {
            plugin.getLogger().severe("Unexpected error parsing page index from title: '" + title + "'. Error: " + e.getMessage());
            return 0; // Default to page 0 on other errors
        }
    }


    // Handles clicks in the OLD main menu (Change Prefix/Suffix) - To be removed later
    private void handleOldTagMenuInteraction(InventoryClickEvent event) {
        Player player = (Player) event.getWhoClicked();
        ItemStack clickedItem = event.getCurrentItem();
        if (clickedItem == null || !clickedItem.hasItemMeta()) return; // Should be caught earlier, but safety first
        String itemName = ChatColor.stripColor(clickedItem.getItemMeta().getDisplayName());

        if ("Change Prefix".equals(itemName)) {
            // Use the manager to open the selection menu
            plugin.getTagMenuManager().openTagSelection(player, 0, TagType.PREFIX);
        } else if ("Change Suffix".equals(itemName)) {
            // Use the manager to open the selection menu
            plugin.getTagMenuManager().openTagSelection(player, 0, TagType.SUFFIX);
        }
    }

    // Handles clicks within the Prefix/Suffix selection menus
    private void handleTagSelection(InventoryClickEvent event, TagType tagType, int currentPage) {
        Player player = (Player) event.getWhoClicked();
        ItemStack clickedItem = event.getCurrentItem();
        // Already checked for null/air/no-meta in onInventoryClick

        ItemMeta meta = clickedItem.getItemMeta();
        String itemName = ChatColor.stripColor(meta.getDisplayName());

        // --- Navigation ---
        if (itemName.equals("Previous Page")) {
            plugin.getTagMenuManager().openTagSelection(player, currentPage - 1, tagType);
            return;
        } else if (itemName.equals("Next Page")) {
            plugin.getTagMenuManager().openTagSelection(player, currentPage + 1, tagType);
            return;
        } else if (itemName.startsWith("Switch to")) {
            TagType otherType = (tagType == TagType.PREFIX) ? TagType.SUFFIX : TagType.PREFIX;
            plugin.getTagMenuManager().openTagSelection(player, 0, otherType);
            return;
        } else if (itemName.startsWith("Remove Current")) {
            removePlayerTag(player, tagType); // removePlayerTag already handles async save
            player.closeInventory(); // Close inventory after removing
            return;
        } else if (itemName.equals("Change Name Color")) { // Handle the new button click
            plugin.getNameColorMenuManager().openNameColorMenu(player); // Open the name color menu
            return; // Exit after handling
        }


        // --- Custom Tag Slot Interaction ---
        if (clickedItem.getType() == Material.WRITABLE_BOOK && itemName.startsWith("Request Custom Tag")) {
            int slotIndex = -1;
            try {
                slotIndex = Integer.parseInt(itemName.replaceAll("[^0-9]", "")) - 1;
            } catch (NumberFormatException e) {
                plugin.getLogger().warning("Could not parse slot index from 'Request Custom Tag' item: " + itemName);
            }
            player.closeInventory();
            player.sendMessage(ChatColor.YELLOW + "To request your custom tag for slot #" + (slotIndex != -1 ? slotIndex + 1 : "?") + ", use:");
            player.sendMessage(ChatColor.WHITE + "/tag request <YourDesiredTagDisplay>");
            player.sendMessage(ChatColor.GRAY + "(Example: /tag request &d[MyTag])");
            return;
        } else if (clickedItem.getType() == Material.BARRIER && itemName.startsWith("Locked Custom Tag")) {
            player.sendMessage(ChatColor.RED + "This custom tag slot is locked. Rank up or visit the store to unlock it.");
            player.closeInventory();
            return;
        }

        // --- Regular Tag or Unlocked Custom Tag Selection ---
        String internalTagName = null;

        // TODO: Prioritize PersistentDataContainer once implemented
        // internalTagName = meta.getPersistentDataContainer().get(tagInternalNameKey, PersistentDataType.STRING);

        // Fallback 1: Check lore
        if (internalTagName == null && meta.hasLore()) {
            for (String loreLine : meta.getLore()) {
                String strippedLore = ChatColor.stripColor(loreLine);
                if (strippedLore.startsWith("ID: ")) {
                    internalTagName = strippedLore.substring("ID: ".length());
                    break;
                }
            }
        }

        // Fallback 2: Player head custom tag
        if (internalTagName == null && clickedItem.getType() == Material.PLAYER_HEAD && itemName.startsWith("Custom Tag #")) {
            try {
                int slotIndex = Integer.parseInt(itemName.replaceAll("[^0-9]", "")) - 1;
                internalTagName = player.getName() + (slotIndex + 1);
            } catch (NumberFormatException e) {
                plugin.getLogger().warning("Could not parse slot index from custom tag item: " + itemName);
            }
        }

        // If name found synchronously, process it. Otherwise, try async fallback.
        if (internalTagName != null) {
                        // --- Check for Right-Click Color Customization ---
            Tag clickedTag = plugin.getTagByName(internalTagName);
            boolean isColorable = clickedTag != null && clickedTag.isColor() && player.hasPermission("utags.color");

            if (event.isRightClick() && isColorable) {
                plugin.getTagColorMenuManager().openColorSelectionMenu(player, clickedTag, true); // Start with bracket editing
                return; // Don't apply tag on right-click
            } else {
                // Left-click or not colorable: Proceed to apply tag
                processTagSelection(player, internalTagName, tagType, clickedItem, meta, itemName);
            }
        } else {
            // Fallback 3: Try to look up internal name by display name asynchronously
            plugin.getLogger().warning("Attempting fallback: Looking up tag by display name: " + meta.getDisplayName());
            String displayToLookup = ChatColor.translateAlternateColorCodes('&', meta.getDisplayName());

            plugin.getTagNameByDisplayAsync(displayToLookup).thenAcceptAsync(resolvedName -> {
                // This block runs after the async DB query completes

                if (resolvedName == null) {
                    // Handle case where lookup failed - run on main thread
                    Bukkit.getScheduler().runTask(plugin, () -> {
                        player.sendMessage(ChatColor.RED + "Error: Could not identify the selected tag (fallback failed).");
                        plugin.getLogger().severe("Failed to determine internal name via fallback for clicked item: " + itemName + " (Material: " + clickedItem.getType() + ")");
                    });
                    return; // Stop processing for this future
                }
                // Name resolved, continue processing - pass to the common handler method
                // Run the rest of the logic on the main thread as it involves Bukkit API calls
                 // Run the rest of the logic on the main thread as it involves Bukkit API calls
                 Bukkit.getScheduler().runTask(plugin, () -> {
                    // Re-check for right-click color customization *after* async lookup
                    Tag resolvedTag = plugin.getTagByName(resolvedName);
                    boolean isColorable = resolvedTag != null && resolvedTag.isColor() && player.hasPermission("utags.color");

                    if (event.isRightClick() && isColorable) {
                        plugin.getTagColorMenuManager().openColorSelectionMenu(player, resolvedTag, true); // Start with bracket editing
                        // Don't process tag selection on right-click
                    } else {
                        // Left-click or not colorable: Proceed to apply tag
                        processTagSelection(player, resolvedName, tagType, clickedItem, meta, itemName);
                    }
                 });
            }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable)); // Ensure Bukkit tasks run on main thread if needed within the lambda
        }
    }

    /**
     * Helper method to handle the logic after the internal tag name has been determined
     * (either synchronously or asynchronously). This part involves permission checks,
     * fetching the display name asynchronously, and applying the tag.
     */
    private void processTagSelection(Player player, String internalTagName, TagType tagType, ItemStack clickedItem, ItemMeta meta, String itemName) {
        // Final check (safety)
        if (internalTagName == null) {
             player.sendMessage(ChatColor.RED + "Error: Could not identify the selected tag.");
             plugin.getLogger().severe("Failed to determine internal name for clicked item: " + itemName + " (Material: " + clickedItem.getType() + ")");
             return;
        }

        // Verify permission (synchronous check is okay here)
        if (!player.hasPermission("utags.tag." + internalTagName)) {
            player.sendMessage(ChatColor.RED + "You don't have permission to use this tag (" + internalTagName + ").");
            return;
        }

        // Get the correct display format asynchronously
        plugin.getTagDisplayByNameAsync(internalTagName).thenAcceptAsync(correctDisplay -> {
            // This block runs asynchronously after the DB query

            // Ensure subsequent Bukkit API calls run on the main thread
            Bukkit.getScheduler().runTask(plugin, () -> {
                if (correctDisplay == null) {
                     player.sendMessage(ChatColor.RED + "Error: Tag data not found in database for ID: " + internalTagName);
                     plugin.getLogger().severe("Tag data missing in DB for existing tag ID: " + internalTagName);
                     return; // Stop processing
                }

                // Get player's color preference and format the display string
                PlayerTagColorPreference preference = plugin.getPlayerTagColorPreference(player.getUniqueId(), internalTagName);
                String finalDisplay = plugin.formatTagDisplayWithColor(correctDisplay, preference);


                // Apply the tag using the INTERNAL NAME.
                // setPlayerTag will handle fetching the display and adding the name color.
                plugin.setPlayerTag(player, internalTagName, tagType);
                player.closeInventory(); // Close inventory on main thread
                player.sendMessage(ChatColor.GREEN + "Your " + tagType.name().toLowerCase() + " has been updated to: " + ChatColor.translateAlternateColorCodes('&', finalDisplay));

                // Optional: Re-open menu logic would also go here if uncommented
                // Bukkit.getScheduler().runTaskLater(plugin, () -> plugin.getTagMenuManager().openTagSelection(player, currentPage, tagType), 1L); // Need currentPage if re-enabling
            });
        }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable)); // Ensure Bukkit tasks run on main thread if needed within the lambda
    }


     private void removePlayerTag(Player player, TagType tagType) {
        User user = plugin.getLuckPerms().getUserManager().getUser(player.getUniqueId());
        if (user != null) {
            // Determine the node type predicate to clear
            NodeType nodeType = (tagType == TagType.PREFIX) ? NodeType.PREFIX : NodeType.SUFFIX;

            // Check if a tag of this type exists *before* clearing
            boolean hadTag = (tagType == TagType.PREFIX) ?
                             (user.getCachedData().getMetaData().getPrefix() != null && !user.getCachedData().getMetaData().getPrefix().isEmpty()) :
                             (user.getCachedData().getMetaData().getSuffix() != null && !user.getCachedData().getMetaData().getSuffix().isEmpty());

            if (hadTag) {
                // Clear existing nodes of that type
                user.data().clear(nodeType.predicate());

                // Save the changes
                plugin.getLuckPerms().getUserManager().saveUser(user).thenRunAsync(() -> {
                    player.sendMessage(ChatColor.GREEN + "Your " + tagType.name().toLowerCase() + " has been removed.");
                }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable)); // Ensure message is sent on main thread
            } else {
                 player.sendMessage(ChatColor.YELLOW + "You did not have a " + tagType.name().toLowerCase() + " set.");
            }
        } // End of if (user != null)
    } // End of removePlayerTag method


    // Handles clicks within the "Confirm Tag Request" menu
    private void handleRequestConfirmation(InventoryClickEvent event) {
        Player player = (Player) event.getWhoClicked();
        ItemStack clickedItem = event.getCurrentItem();
        // Meta already checked for null in onInventoryClick

        ItemMeta meta = clickedItem.getItemMeta();
        String itemName = ChatColor.stripColor(meta.getDisplayName());

        if (itemName.equals("Confirm Request")) {
            // Find the preview item to get the tag display
            ItemStack previewItem = event.getInventory().getItem(4); // Assuming preview is at slot 4
            String requestedTagDisplay = null;

            if (previewItem != null && previewItem.hasItemMeta() && previewItem.getItemMeta().hasLore()) {
                // Extract tag from the first line of lore.
                // WARNING: This retrieves the *already translated* tag display.
                // This assumes createCustomTagRequest can handle it or was designed for it.
                // A better approach is storing the original string in PersistentDataContainer.
                List<String> lore = previewItem.getItemMeta().getLore();
                if (!lore.isEmpty()) {
                    // The first line in the confirmation GUI lore is the translated tag
                    requestedTagDisplay = lore.get(0);
                    // We need the raw display with '&' codes for createCustomTagRequest
                    // Let's try to reverse the translation (this is brittle)
                    requestedTagDisplay = requestedTagDisplay.replace("§", "&");

                }
            }

            if (requestedTagDisplay != null) {
                // Trim again just in case something went wrong
                 int endIndex = requestedTagDisplay.indexOf(']') + 1;
                 if (endIndex > 0 && endIndex < requestedTagDisplay.length()) {
                     requestedTagDisplay = requestedTagDisplay.substring(0, endIndex);
                }

               // Call the asynchronous method in uTags.java
               plugin.createCustomTagRequestAsync(player, requestedTagDisplay);
               // Close inventory immediately, feedback will be sent asynchronously
               player.closeInventory();
               // Confirmation/error message is now handled within createCustomTagRequestAsync's callback
           } else {
               player.sendMessage(ChatColor.RED + "Error retrieving tag preview. Please try again.");
                player.closeInventory();
                plugin.getLogger().warning("Could not retrieve requestedTagDisplay from confirmation GUI lore for player " + player.getName());
            }

        } else if (itemName.equals("Cancel")) {
            player.sendMessage(ChatColor.YELLOW + "Tag request cancelled.");
            player.closeInventory();
        }
        // Ignore clicks on other items like the preview item itself
    }


    // --- Methods below were moved to TagMenuManager ---
    // openTagSelection(...)
    // populateTagSelectionInventory(...)
    // addExtraMenuItems(...)
    // addPlayerHead(...)
    // createNavigationArrow(...)
    // createInventoryFrame(...)
    // createCustomTagMenuItem(...)

}
</file>

<file path="src/main/java/com/blockworlds/utags/uTags.java">
package com.blockworlds.utags;

import net.luckperms.api.LuckPerms;
import net.luckperms.api.LuckPermsProvider;
import net.luckperms.api.model.user.User;
import net.luckperms.api.node.Node;
import net.luckperms.api.node.NodeType;
import net.luckperms.api.node.types.PrefixNode;
import net.luckperms.api.node.types.SuffixNode;
// Removed incorrect import: import net.luckperms.api.cacheddata.MetaData;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.util.io.BukkitObjectInputStream;
import org.bukkit.util.io.BukkitObjectOutputStream;

import com.blockworlds.utags.TagColorMenuManager;
import java.util.concurrent.ConcurrentHashMap;
import com.zaxxer.hikari.HikariDataSource;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.sql.*;
import java.util.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import com.zaxxer.hikari.HikariConfig;
import java.util.concurrent.CompletableFuture;

public class uTags extends JavaPlugin {

    // Removed host, port, database, username, password - now read from env vars
    private String defaultTag;
    private LuckPerms luckPerms;
    private TagMenuManager tagMenuManager;
    private HikariDataSource dataSource;
    private AdminMenuManager adminMenuManager;
    private TagColorMenuManager tagColorMenuManager;
    private NameColorMenuManager nameColorMenuManager; // Added for Name Color GUI

    private final Map<UUID, String> previewTags = Collections.synchronizedMap(new HashMap<>());

    // Stores player-specific color preferences for tags
    // Key: Player UUID, Value: Map<TagName, PreferenceObject>
    private final Map<UUID, Map<String, PlayerTagColorPreference>> playerColorPreferences = new ConcurrentHashMap<>(); // For tag-specific colors
    // Stores player-specific name color preferences (&a, &c, etc., or null for default)
    private final Map<UUID, String> playerNameColorPreferences = new ConcurrentHashMap<>();
    // Stores the NAME of the prefix tag currently applied to the player
    public final Map<UUID, String> playerAppliedPrefixTagName = new ConcurrentHashMap<>(); // Made public for LoginListener access
    @Override
    public void onEnable() {
        setupTagColorMenuManager();
        setupNameColorMenuManager(); // Added for Name Color GUI
        setupLuckPerms();
        // LuckPerms listener registration is now handled within setupLuckPerms()
        // Initialize managers before registering listeners that depend on them
        setupTagMenuManager();
        setupAdminMenuManager();
        registerCommandsAndEvents(); // Now managers are not null

        loadConfig();
        setupDatabase();
        updateDatabaseSchema();
        cleanupInvalidMaterials();
        loadAllPlayerNameColorsAsync(); // Load name colors on startup
    }

    // --- Constants ---
    public static final int TAG_PREFIX_PRIORITY = 10000; // Priority for uTags prefixes
    public static final int NAME_COLOR_SUFFIX_PRIORITY = 100; // Priority for uTags name color suffixes

    @Override
    public void onDisable() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
            getLogger().info("Database connection pool closed.");
        }
    }

    public LuckPerms getLuckPerms() {
        return luckPerms;
    }

    private void setupLuckPerms() {
        if (getServer().getPluginManager().getPlugin("LuckPerms") != null) {
            luckPerms = LuckPermsProvider.get();
            // Register the LuckPerms listener *after* successfully getting the API instance
            // new LuckPermsListener(this, luckPerms); // Instantiate to register with LuckPerms event bus - Disabled to prevent feedback loop
        } else {
            getLogger().warning("LuckPerms not found! Cannot register listener. Disabling uTags...");
            getServer().getPluginManager().disablePlugin(this);
        }
    }


    // Listener registration removed

    public void registerCommandsAndEvents() { // Made public for testing
        TagCommand tagCommand = new TagCommand(this);
        // Existing Listeners
        getServer().getPluginManager().registerEvents(new TagColorMenuListener(this, this.tagColorMenuManager), this);
        getServer().getPluginManager().registerEvents(new TagMenuListener(this), this);
        getServer().getPluginManager().registerEvents(new RequestMenuClickListener(this), this);
        getServer().getPluginManager().registerEvents(new TagCommandPreviewListener(this), this);
        getServer().getPluginManager().registerEvents(new LoginListener(this), this);
        getServer().getPluginManager().registerEvents(new AdminMenuListener(this, this.adminMenuManager), this);
        // Added for Name Color GUI
        getServer().getPluginManager().registerEvents(new NameColorMenuListener(this), this);

        // Existing Commands
        getCommand("tag").setExecutor(tagCommand);
        getCommand("tag").setTabCompleter(tagCommand);
        // Added for Name Color GUI
        getCommand("name").setExecutor(new NameCommand(this, this.nameColorMenuManager)); // Changed command name and class

        long delay = 5 * 60 * 20; // 5 minutes in ticks (20 ticks per second)
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            if (!getCustomTagRequests().isEmpty()) {
                for (Player player : Bukkit.getOnlinePlayers()) {
                    if (player.hasPermission("utags.staff")) {
                        player.sendMessage(ChatColor.RED + "There are pending tag requests. Use " + ChatColor.YELLOW + "/tag admin requests" + ChatColor.RED + " to check them.");
                    }
                }
            }
        }, delay, delay);
    }

    public boolean hasPendingTagRequests() {
        return getCustomTagRequests() != null && !getCustomTagRequests().isEmpty();
    }
    private void setupTagMenuManager() {
        this.tagMenuManager = new TagMenuManager(this);
    }


    private void setupAdminMenuManager() {
        if (this.tagMenuManager == null) {
            // Ensure TagMenuManager is initialized first
            setupTagMenuManager();
        }
        this.adminMenuManager = new AdminMenuManager(this, this.tagMenuManager);
    }

    private void setupTagColorMenuManager() {
        this.tagColorMenuManager = new TagColorMenuManager(this);
    }

    // Added for Name Color GUI
    private void setupNameColorMenuManager() {
        this.nameColorMenuManager = new NameColorMenuManager(this);
    }


    private void loadConfig() {
        saveDefaultConfig();
        FileConfiguration config = getConfig();
        defaultTag = config.getString("default-tag");
    }

    private void setupDatabase() {
        try {
            // Configure HikariCP
            HikariConfig config = new HikariConfig();
            // Check for explicit driver/url (for H2 testing or other DBs)
            String driverClassName = getConfig().getString("database.driverClassName");
            String jdbcUrl = getConfig().getString("database.jdbcUrl");
            // Read database credentials from config.yml
            String dbHost = getConfig().getString("database.host", "localhost");
            int dbPort = getConfig().getInt("database.port", 3306);
            String dbName = getConfig().getString("database.database", "utags");
            String dbUser = getConfig().getString("database.username", "user");
            String dbPass = getConfig().getString("database.password", "password");

            // Log the credentials being used (excluding password for security)
            getLogger().info("Connecting to database: " + dbHost + ":" + dbPort + "/" + dbName + " as user: " + dbUser);


            if (driverClassName != null && !driverClassName.isEmpty() && jdbcUrl != null && !jdbcUrl.isEmpty()) {
                // Use explicit driver and URL if provided
                config.setDriverClassName(driverClassName);
                config.setJdbcUrl(jdbcUrl);
                getLogger().info("Using custom JDBC driver and URL from config.");
            } else {
                // Construct MySQL URL using config values
                config.setJdbcUrl("jdbc:mysql://" + dbHost + ":" + dbPort + "/" + dbName + "?autoReconnect=true&useSSL=false");
                getLogger().info("Using MySQL JDBC URL constructed from config.yml values.");
            }

            // Set common pool properties using config values
            config.setUsername(dbUser);
            config.setPassword(dbPass);
            config.setMaximumPoolSize(10);
            config.setMinimumIdle(5);
            config.setConnectionTimeout(30000); // 30 seconds
            config.setIdleTimeout(600000); // 10 minutes
            config.setMaxLifetime(1800000); // 30 minutes
            
            // Initialize the connection pool
            dataSource = new HikariDataSource(config);
            getLogger().info("Database connection pool initialized successfully");
            
            // Create tables if they don't exist
            try (Connection connection = dataSource.getConnection()) {
                createTagsTableIfNotExists(connection);
                getLogger().info("Database tables verified/created successfully");
            }
        } catch (SQLException e) {
            getLogger().severe("Error setting up the MySQL database: " + e.getMessage());
            getLogger().severe("Please check your database configuration in config.yml");
            // Log more details but don't crash the plugin
            e.printStackTrace();
            
            // Disable the plugin gracefully
            getLogger().severe("Disabling uTags plugin due to database connection failure");
            getServer().getPluginManager().disablePlugin(this);
        }
    }

    private void createTagsTableIfNotExists(Connection connection) throws SQLException {
        try (Statement statement = connection.createStatement()) {
            statement.executeUpdate(
                    "CREATE TABLE IF NOT EXISTS `tags` (" +
                            "`id` INT AUTO_INCREMENT PRIMARY KEY," +
                            "`name` VARCHAR(255) NOT NULL," +
                            "`display` VARCHAR(255) NOT NULL," +
                            "`type` ENUM('prefix', 'suffix', 'both') NOT NULL," +
                            "`public` BOOLEAN NOT NULL," +
                            "`color` BOOLEAN NOT NULL," +
                            "`material` MEDIUMTEXT NOT NULL," +
                            "`weight` INT NOT NULL" +
                            ");"
            );
            statement.executeUpdate("CREATE TABLE IF NOT EXISTS `tag_requests` ("
                    + "`id` INT AUTO_INCREMENT PRIMARY KEY,"
                    + "`player_uuid` VARCHAR(36) NOT NULL,"
                    + "`player_name` VARCHAR(255) NOT NULL,"
                    + "`tag_display` VARCHAR(255) NOT NULL);");

           // Add player_preferences table for name colors
           statement.executeUpdate("CREATE TABLE IF NOT EXISTS `player_preferences` ("
                   + "`player_uuid` VARCHAR(36) PRIMARY KEY NOT NULL,"
                   + "`name_color_code` VARCHAR(2) NULL" // Allow NULL for reset/default
                   + ");");
           // Add player_tag_color_preferences table
           statement.executeUpdate("CREATE TABLE IF NOT EXISTS `player_tag_color_preferences` (" +
                   "`player_uuid` VARCHAR(36) NOT NULL," +
                   "`tag_name` VARCHAR(255) NOT NULL," +
                   "`bracket_color_code` VARCHAR(2) NULL," +
                   "`content_color_code` VARCHAR(2) NULL," +
                   "PRIMARY KEY (`player_uuid`, `tag_name`)" +
                   ");");
       }
    }

    /**
     * Gets a database connection from the connection pool.
     * The connection must be closed by the caller after use.
     *
     * @return A database connection from the pool
     * @throws SQLException if a database access error occurs
     */
    public Connection getConnection() throws SQLException {
        if (dataSource == null || dataSource.isClosed()) {
            getLogger().severe("Database connection pool is closed or not initialized!");
            throw new SQLException("Database connection pool is not available");
        }
        
        try {
            return dataSource.getConnection();
        } catch (SQLException e) {
            getLogger().severe("Failed to get database connection: " + e.getMessage());
            throw e;
        }
    }

    public String getDefaultTag() {
        return defaultTag;
    }

    public TagMenuManager getTagMenuManager() {
        return tagMenuManager;
    }



    public TagColorMenuManager getTagColorMenuManager() {
        return tagColorMenuManager;
    }

    public AdminMenuManager getAdminMenuManager() {
        return adminMenuManager;
    }

    // Added for Name Color GUI access
    public NameColorMenuManager getNameColorMenuManager() {
        return nameColorMenuManager;
    }

    // Removed unused stubs getPlayerDataConfig and savePlayerDataConfig



    public List<Tag> getAvailableTags(TagType tagType) {
        List<Tag> availableTags = new ArrayList<>();

        try (Connection connection = getConnection();
             Statement statement = connection.createStatement()) {

            ResultSet resultSet = getTagsResultSet(tagType, statement);

            while (resultSet.next()) {
                availableTags.add(createTagFromResultSet(resultSet));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return availableTags;
    }

    private ResultSet getTagsResultSet(TagType tagType, Statement statement) throws SQLException {
        if (tagType == TagType.PREFIX) {
            return statement.executeQuery("SELECT * FROM tags WHERE type = 'prefix' OR type = 'both' ORDER BY weight DESC;");
        } else if (tagType == TagType.SUFFIX) {
            return statement.executeQuery("SELECT * FROM tags WHERE type = 'suffix' OR type = 'both' ORDER BY weight DESC;");
        } else {
            return statement.executeQuery("SELECT * FROM tags ORDER BY weight DESC;");
        }
    }

    private Tag createTagFromResultSet(ResultSet resultSet) throws SQLException {
        String name = resultSet.getString("name");
        String display = resultSet.getString("display");
        
        // Handle case-insensitive enum values
        String typeStr = resultSet.getString("type").toUpperCase();
        TagType type;
        try {
            type = TagType.valueOf(typeStr);
        } catch (IllegalArgumentException e) {
            getLogger().warning("Invalid tag type found in database: " + typeStr + ". Defaulting to PREFIX.");
            type = TagType.PREFIX;
        }
        
        boolean isPublic = resultSet.getBoolean("public");
        boolean color = resultSet.getBoolean("color");
        ItemStack material = deserializeMaterial(resultSet.getString("material"));
        int weight = resultSet.getInt("weight");

        return new Tag(name, display, type, isPublic, color, material, weight);
    }

    // Removed commented-out code
    public void cleanupInvalidMaterials() {
        getLogger().info("Checking for invalid player head materials...");
        
        // First, verify the table structure to make sure we have the right columns
        List<String> columns = new ArrayList<>();
        try (Connection conn = getConnection();
             ResultSet rs = conn.getMetaData().getColumns(null, null, "tags", null)) {
            
            while (rs.next()) {
                columns.add(rs.getString("COLUMN_NAME").toLowerCase());
            }
            
            getLogger().info("Found columns: " + String.join(", ", columns));
        } catch (SQLException e) {
            getLogger().severe("Error checking table structure: " + e.getMessage());
            e.printStackTrace();
            return;
        }
        
        // Determine which column to use for the WHERE clause based on what's available
        String idColumn = columns.contains("id") ? "id" : "name";
        getLogger().info("Using column '" + idColumn + "' as identifier for updates");
        
        try (Connection conn = getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT " + idColumn + ", name, material FROM tags")) {
            
            int cleanedCount = 0;
            
            while (rs.next()) {
                String identifier = rs.getString(idColumn);
                String tagName = rs.getString("name");
                String materialData = rs.getString("material");
                
                boolean needsRepair = false;
                
                try {
                    // Try to deserialize to test if it's valid
                    ByteArrayInputStream inputStream = new ByteArrayInputStream(Base64.getDecoder().decode(materialData));
                    try (BukkitObjectInputStream dataInput = new BukkitObjectInputStream(inputStream)) {
                        dataInput.readObject();
                    }
                } catch (Exception e) {
                    // If any exception occurs during deserialization, mark for repair
                    getLogger().warning("Error deserializing material for tag '" + tagName + "': " + e.getMessage());
                    needsRepair = true;
                }
                
                if (needsRepair) {
                    getLogger().warning("Repairing invalid material for tag '" + tagName + "'");
                    
                    // Create a replacement item
                    ItemStack replacementItem = new ItemStack(Material.NAME_TAG);
                    String serialized;
                    
                    try {
                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                        try (BukkitObjectOutputStream dataOutput = new BukkitObjectOutputStream(outputStream)) {
                            dataOutput.writeObject(replacementItem);
                        }
                        serialized = Base64.getEncoder().encodeToString(outputStream.toByteArray());
                        
                        try (PreparedStatement ps = conn.prepareStatement(
                                "UPDATE tags SET material = ? WHERE " + idColumn + " = ?")) {
                            ps.setString(1, serialized);
                            ps.setString(2, identifier);
                            int updated = ps.executeUpdate();
                            
                            if (updated > 0) {
                                cleanedCount++;
                                getLogger().info("Successfully repaired tag '" + tagName + "'");
                            } else {
                                getLogger().warning("Failed to repair tag '" + tagName + "', no rows updated");
                            }
                        }
                    } catch (Exception e) {
                        getLogger().severe("Error while trying to repair tag '" + tagName + "': " + e.getMessage());
                        e.printStackTrace();
                    }
                }
            }
            
            if (cleanedCount > 0) {
                getLogger().info("Repaired " + cleanedCount + " invalid material entries.");
            } else {
                getLogger().info("No invalid material entries found or repaired.");
            }
        } catch (SQLException e) {
            getLogger().severe("Error cleaning up invalid materials: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private ItemStack deserializeMaterial(String base64Material) {
        if (base64Material == null || base64Material.isEmpty()) {
            getLogger().warning("Empty or null material data encountered, using default material.");
            return new ItemStack(Material.NAME_TAG);
        }
        
        try {
            ByteArrayInputStream inputStream = new ByteArrayInputStream(Base64.getDecoder().decode(base64Material));
            try (BukkitObjectInputStream dataInput = new BukkitObjectInputStream(inputStream)) {
                return (ItemStack) dataInput.readObject();
            }
        } catch (Exception e) {
            getLogger().warning("Error deserializing material: " + e.getMessage());
            
            // Debug information
            if (base64Material != null) {
                getLogger().info("Base64 length: " + base64Material.length());
                getLogger().info("Base64 prefix: " + 
                    (base64Material.length() > 20 ? base64Material.substring(0, 20) + "..." : base64Material));
            }
            
            // Return a default item based on the error
            if (e.toString().contains("invalid characters") || e.toString().contains("Head Database")) {
                // For player head errors
                return new ItemStack(Material.NAME_TAG);
            } else {
                // For other errors, use NAME_TAG as a fallback
                return new ItemStack(Material.NAME_TAG);
            }
        }
    }

    public void addTagToDatabase(Tag tag) {
        try (Connection connection = getConnection();
             PreparedStatement statement = prepareInsertTagStatement(connection, tag)) {
            statement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private PreparedStatement prepareInsertTagStatement(Connection connection, Tag tag) throws SQLException {
        PreparedStatement statement = connection.prepareStatement("REPLACE INTO tags (name, display, type, public, color, material, weight) VALUES (?, ?, ?, ?, ?, ?, ?)");

        statement.setString(1, tag.getName());
        statement.setString(2, tag.getDisplay());
        statement.setString(3, tag.getType().toString());
        statement.setBoolean(4, tag.isPublic());
        statement.setBoolean(5, tag.isColor());
        statement.setString(6, serializeMaterial(tag.getMaterial()));
        statement.setInt(7, tag.getWeight());
        return statement;
    }

    public String serializeMaterial(ItemStack material) { // Changed to public
        try {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            try (BukkitObjectOutputStream dataOutput = new BukkitObjectOutputStream(outputStream)) {
                dataOutput.writeObject(material);
            }
            return Base64.getEncoder().encodeToString(outputStream.toByteArray());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void deleteTagFromDatabase(String tagName) {
        try (Connection connection = getConnection();
             PreparedStatement statement = prepareDeleteTagStatement(connection, tagName)) {
            statement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private PreparedStatement prepareDeleteTagStatement(Connection connection, String tagName) throws SQLException {
        PreparedStatement statement = connection.prepareStatement("DELETE FROM tags WHERE name = ?");
        statement.setString(1, tagName);
        return statement;
    }

    public void purgeTagsTable() {
        try (Connection connection = getConnection();
             Statement statement = connection.createStatement()) {
            dropTagsTable(statement);
            recreateTagsTable(statement);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void purgeRequestsTable() {
        try (Connection connection = getConnection();
             Statement statement = connection.createStatement()) {
            dropRequestsTable(statement);
            recreateRequestsTable(statement);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void dropTagsTable(Statement statement) throws SQLException {
        String dropTableQuery = "DROP TABLE IF EXISTS tags";
        statement.executeUpdate(dropTableQuery);
    }

    private void dropRequestsTable(Statement statement) throws SQLException {
        String dropTableQuery = "DROP TABLE IF EXISTS tag_requests";
        statement.executeUpdate(dropTableQuery);
    }

    private void recreateTagsTable(Statement statement) throws SQLException {
        String createTable = "CREATE TABLE IF NOT EXISTS tags (" +
                "`name` VARCHAR(255) PRIMARY KEY," +
                "`display` VARCHAR(255) NOT NULL," +
                "`type` ENUM('prefix', 'suffix', 'both') NOT NULL," +
                "`public` BOOLEAN NOT NULL," +
                "`color` BOOLEAN NOT NULL," +
                "`material` MEDIUMTEXT NOT NULL," +
                "`weight` INT NOT NULL" +
                ");";
        statement.executeUpdate(createTable);
    }

    private void recreateRequestsTable(Statement statement) throws SQLException {
        String createTable = ("CREATE TABLE IF NOT EXISTS `tag_requests` ("
                + "`id` INT AUTO_INCREMENT PRIMARY KEY,"
                + "`player_uuid` VARCHAR(36) NOT NULL,"
                + "`player_name` VARCHAR(255) NOT NULL,"
                + "`tag_display` VARCHAR(255) NOT NULL);");
        statement.executeUpdate(createTable);
    }

    public void updateDatabaseSchema() {
        int currentSchemaVersion = getConfig().getInt("database.schema");
        int latestSchemaVersion = 3; // Update this value when the schema changes
        getLogger().info("Checking if database schema needs an update...");

        if (currentSchemaVersion < latestSchemaVersion) {
            getLogger().info("Schema version " + currentSchemaVersion + " needs to be updated to version " + latestSchemaVersion);

            try (Connection connection = getConnection()) {
                updateSchemaVersions(connection, currentSchemaVersion, latestSchemaVersion);
                updateConfigSchemaVersion(latestSchemaVersion);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    private void updateSchemaVersions(Connection connection, int currentSchemaVersion, int latestSchemaVersion) throws SQLException {
        for (int i = currentSchemaVersion + 1; i <= latestSchemaVersion; i++) {
            switch (i) {
                case 3:
                    addMaterialColumnIfNotExists(connection);
                    break;
                // Add more cases for future schema updates
            }
        }
    }

    private void addMaterialColumnIfNotExists(Connection connection) throws SQLException {
        DatabaseMetaData metaData = connection.getMetaData();
        ResultSet resultSet = metaData.getColumns(null, null, "tags", "material");
        if (!resultSet.next()) {
            try (Statement statement = connection.createStatement()) {
                String alterTable = "ALTER TABLE tags MODIFY COLUMN `material` MEDIUMTEXT NOT NULL;";
                statement.executeUpdate(alterTable);
            }
        }
    }

    private void updateConfigSchemaVersion(int latestSchemaVersion) {
        getConfig().set("database.schema", latestSchemaVersion);
        saveConfig();
    }

    /**
     * Asynchronously creates or updates a custom tag request in the database.
     *
     * @param player     The player making the request.
     * @param tagDisplay The requested tag display string.
     * @return A CompletableFuture that completes when the operation is finished.
     */
    public CompletableFuture<Void> createCustomTagRequestAsync(Player player, String tagDisplay) {
        // Basic synchronous validation
        if (tagDisplay == null || tagDisplay.trim().isEmpty()) {
            player.sendMessage(ChatColor.RED + "Tag display cannot be empty.");
            return CompletableFuture.completedFuture(null); // Complete immediately
        }

        // Simple trim based on ']' - Keep original logic for now
        int endIndex = tagDisplay.indexOf(']') + 1;
        if (endIndex > 0 && endIndex < tagDisplay.length()) { // Ensure endIndex is valid and not the whole string
            tagDisplay = tagDisplay.substring(0, endIndex);
        }
        // Further validation could be added here if needed

        // Use final variables for lambda
        final String finalTagDisplay = tagDisplay.trim(); // Trim before using
        final String playerUUID = player.getUniqueId().toString();
        final String playerName = player.getName(); // Capture name now

        if (finalTagDisplay.isEmpty()) {
             player.sendMessage(ChatColor.RED + "Tag display became empty after trimming.");
             return CompletableFuture.completedFuture(null);
        }

        // Run database operations asynchronously
        return CompletableFuture.runAsync(() -> {
            boolean updateFailed = false;
            boolean insertFailed = false;
            boolean checkFailed = false;
            boolean updated = false;

            try (Connection connection = getConnection();
                 PreparedStatement checkExistingRequest = connection.prepareStatement(
                         "SELECT id FROM tag_requests WHERE player_uuid = ? LIMIT 1")) { // Optimized query

                checkExistingRequest.setString(1, playerUUID);
                ResultSet resultSet = checkExistingRequest.executeQuery();

                if (resultSet.next()) {
                    // Request exists, update it
                    try (PreparedStatement updateRequest = connection.prepareStatement(
                            "UPDATE tag_requests SET player_name = ?, tag_display = ? WHERE player_uuid = ?")) {
                        updateRequest.setString(1, playerName);
                        updateRequest.setString(2, finalTagDisplay);
                        updateRequest.setString(3, playerUUID);
                        updateRequest.executeUpdate();
                        updated = true; // Mark as updated
                    } catch (SQLException e) {
                        getLogger().severe("Error updating tag request for " + playerName + ": " + e.getMessage());
                        e.printStackTrace();
                        updateFailed = true;
                    }
                } else {
                    // Request doesn't exist, insert it
                    try (PreparedStatement insertRequest = connection.prepareStatement(
                            "INSERT INTO tag_requests (player_uuid, player_name, tag_display) VALUES (?, ?, ?)")) {
                        insertRequest.setString(1, playerUUID);
                        insertRequest.setString(2, playerName);
                        insertRequest.setString(3, finalTagDisplay);
                        insertRequest.executeUpdate();
                        // No need for 'updated' flag here, success is implied if no exception
                    } catch (SQLException e) {
                        getLogger().severe("Error inserting tag request for " + playerName + ": " + e.getMessage());
                        e.printStackTrace();
                        insertFailed = true;
                    }
                }
            } catch (SQLException e) {
                getLogger().severe("Error checking existing tag request for " + playerName + ": " + e.getMessage());
                e.printStackTrace();
                checkFailed = true;
            }

            // Send feedback to the player back on the main thread
            final boolean finalCheckFailed = checkFailed;
            final boolean finalUpdateFailed = updateFailed;
            final boolean finalInsertFailed = insertFailed;
            final boolean finalUpdated = updated;

            Bukkit.getScheduler().runTask(this, () -> {
                if (finalCheckFailed) {
                    player.sendMessage(ChatColor.RED + "An error occurred while checking for existing requests.");
                } else if (finalUpdateFailed) {
                    player.sendMessage(ChatColor.RED + "An error occurred while updating your tag request.");
                } else if (finalInsertFailed) {
                    player.sendMessage(ChatColor.RED + "An error occurred while submitting your tag request.");
                } else if (finalUpdated) {
                    player.sendMessage(ChatColor.GREEN + "Your existing tag request has been updated with the new one!");
                } else {
                    player.sendMessage(ChatColor.GREEN + "Your tag request has been submitted!");
                }
            });
        });
    }

    public int countCustomTags(String playerName) {
        // Count the number of custom tags for a player
        try (Connection connection = getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT COUNT(*) FROM tags WHERE name LIKE ?")) {

            statement.setString(1, playerName + "%");
            ResultSet resultSet = statement.executeQuery();
            if (resultSet.next()) {
                return resultSet.getInt(1);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public List<CustomTagRequest> getCustomTagRequests() {
        List<CustomTagRequest> requests = new ArrayList<>();
        try (Connection connection = getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT * FROM tag_requests");
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                UUID playerUuid = UUID.fromString(resultSet.getString("player_uuid"));
                String playerName = resultSet.getString("player_name");
                String tagDisplay = resultSet.getString("tag_display");
                requests.add(new CustomTagRequest(id, playerUuid, playerName, tagDisplay));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return requests;
    }

    public CustomTagRequest getCustomTagRequestByPlayerName(String playerName) {
        CustomTagRequest request = null;
        try (Connection connection = getConnection()) {
            PreparedStatement statement = connection.prepareStatement("SELECT * FROM tag_requests WHERE player_name = ?;");
            statement.setString(1, playerName);
            ResultSet resultSet = statement.executeQuery();
            if (resultSet.next()) {
                int id = resultSet.getInt("id");
                UUID playerUuid = UUID.fromString(resultSet.getString("player_uuid"));
                String display = resultSet.getString("tag_display");
                request = new CustomTagRequest(id, playerUuid, playerName, display);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return request;
    }

    public void acceptCustomTagRequest(CustomTagRequest request) {
        try (Connection connection = getConnection()) {
            String permission = "utags.tag." + request.getPlayerName() + (countCustomTags(request.getPlayerName()) + 1);
            // Add the new tag to the tags table
            addTagToDatabase(new Tag(request.getPlayerName() + (countCustomTags(request.getPlayerName()) + 1), request.getTagDisplay(), TagType.PREFIX, false, false, new ItemStack(Material.PLAYER_HEAD),1));

            // Remove the request from the tag_requests table
            removeCustomRequestFromDatabase(request);
            getLuckPerms().getUserManager().loadUser(request.getPlayerUuid()).thenAcceptAsync(user -> {
                user.data().add(Node.builder(permission).build());
                getLuckPerms().getUserManager().saveUser(user);

                // Execute the configured command to notify the player
                String command = getConfig().getString("accept-command", "mail send %player% Your custom tag request has been accepted!");
                command = command.replace("%player%", request.getPlayerName());
                String finalCommand = command;
                Bukkit.getScheduler().runTask(this, () -> Bukkit.dispatchCommand(Bukkit.getConsoleSender(), finalCommand));
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void removeCustomRequestFromDatabase(CustomTagRequest request) {
        try (Connection connection = getConnection()) {
            PreparedStatement statement = connection.prepareStatement("DELETE FROM tag_requests WHERE id = ?;");
            statement.setInt(1, request.getId());
            statement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void denyCustomTagRequest(CustomTagRequest request) {
        try (Connection connection = getConnection()) {
            PreparedStatement statement = connection.prepareStatement("DELETE FROM tag_requests WHERE id = ?;");
            statement.setInt(1, request.getId());
            statement.executeUpdate();
            // Execute the configured command to notify the player
            String command = getConfig().getString("deny-command", "mail send %player% Your custom tag request has been denied.");
            command = command.replace("%player%", request.getPlayerName());
            Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void openRequestsMenu(Player player) {
        List<CustomTagRequest> requests = new ArrayList<>();
        try (Connection connection = getConnection()) {
            PreparedStatement statement = connection.prepareStatement("SELECT * FROM tag_requests;");
            ResultSet resultSet = statement.executeQuery();
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                UUID playerUuid = UUID.fromString(resultSet.getString("player_uuid"));
                String playerName = resultSet.getString("player_name");
                String display = resultSet.getString("tag_display");
                requests.add(new CustomTagRequest(id, playerUuid, playerName, display));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        // Now create the inventory GUI and open it for the player
        openRequestsMenu(player, requests);
    }

    public void openRequestsMenu(Player player, List<CustomTagRequest> requests) {
        // Ensure minimum size of 9 (1 row) and maximum of 54 (6 rows)
        // Also ensure we have enough space for all requests
        int rows = Math.max(1, (int) Math.ceil(requests.size() / 9.0));
        rows = Math.min(rows, 6);  // Maximum 6 rows in a chest GUI
        int size = rows * 9;       // Size must be a multiple of 9
        
        Inventory inventory = Bukkit.createInventory(null, size, ChatColor.BLUE + "Custom Tag Requests");

        for (CustomTagRequest request : requests) {
            ItemStack item = new ItemStack(Material.PLAYER_HEAD);
            SkullMeta skullMeta = (SkullMeta) item.getItemMeta();
            skullMeta.setOwningPlayer(Bukkit.getOfflinePlayer(request.getPlayerUuid()));
            skullMeta.setDisplayName(ChatColor.GREEN + request.getPlayerName());
            List<String> lore = new ArrayList<>();
            lore.add(ChatColor.GRAY + "Requested Tag: " + ChatColor.translateAlternateColorCodes('&', request.getTagDisplay()));
            lore.add("");
            lore.add(ChatColor.YELLOW + "Left-click to accept");
            lore.add(ChatColor.RED + "Right-click to deny");
            skullMeta.setLore(lore);
            item.setItemMeta(skullMeta);
            inventory.addItem(item);
        }

        player.openInventory(inventory);
    }

    public boolean editTagAttribute(String tagName, String attribute, String newValue) {
        // List of allowed attribute names to prevent SQL injection
        Set<String> allowedAttributes = new HashSet<>(Arrays.asList("name", "display", "type", "public", "color", "material", "weight"));
        
        // Verify the attribute is valid
        if (!allowedAttributes.contains(attribute.toLowerCase())) {
            return false;
        }
        
        try (Connection connection = getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT * FROM tags WHERE name = ?")) {
            statement.setString(1, tagName);
            ResultSet resultSet = statement.executeQuery();

            if (!resultSet.next()) {
                return false;
            }

            // Use prepared statements with the validated attribute name
            String sql = "";
            switch(attribute.toLowerCase()) {
                case "name": sql = "UPDATE tags SET name = ? WHERE name = ?"; break;
                case "display": sql = "UPDATE tags SET display = ? WHERE name = ?"; break;
                case "type": sql = "UPDATE tags SET type = ? WHERE name = ?"; break;
                case "public": sql = "UPDATE tags SET public = ? WHERE name = ?"; break;
                case "color": sql = "UPDATE tags SET color = ? WHERE name = ?"; break;
                case "material": sql = "UPDATE tags SET material = ? WHERE name = ?"; break;
                case "weight": sql = "UPDATE tags SET weight = ? WHERE name = ?"; break;
                default: return false; // This shouldn't happen due to the validation above
            }
            
            try (PreparedStatement updateStatement = connection.prepareStatement(sql)) {
                updateStatement.setString(1, newValue);
                updateStatement.setString(2, tagName);
                updateStatement.executeUpdate();
                return true;
            }
        } catch (SQLException e) {
            getLogger().severe("Error updating tag attribute: " + e.getMessage());
            e.printStackTrace();
        }
            return false;
        }

    /**
     * Formats a tag display string based on player's color preferences.
     * Assumes display format like "[content]".
     *
     * @param originalDisplay The original tag display string (e.g., "&a[VIP]").
     * @param preference      The player's color preference object for this tag.
     * @return The formatted string with custom colors applied, or the original string if no preferences are set.
     */
    public String formatTagDisplayWithColor(String originalDisplay, PlayerTagColorPreference preference) {
        if (preference == null || preference.isDefault()) {
            return originalDisplay; // No custom colors set
        }

        ChatColor bracketColor = preference.getBracketColor();
        ChatColor contentColor = preference.getContentColor();

        // Find the positions of the brackets
        int openBracketIndex = originalDisplay.indexOf('[');
        int closeBracketIndex = originalDisplay.indexOf(']');

        // If brackets aren't found, return original (or handle error)
        if (openBracketIndex == -1 || closeBracketIndex == -1 || openBracketIndex >= closeBracketIndex) {
            getLogger().warning("Could not parse brackets in tag display: " + originalDisplay);
            return originalDisplay;
        }

        String prefix = originalDisplay.substring(0, openBracketIndex); // Colors before the opening bracket
        String content = originalDisplay.substring(openBracketIndex + 1, closeBracketIndex);
        String suffix = originalDisplay.substring(closeBracketIndex + 1); // Text/colors after the closing bracket

        StringBuilder formatted = new StringBuilder();

        // Apply prefix colors
        formatted.append(prefix);

        // Apply bracket color
        if (bracketColor != null) {
            formatted.append(bracketColor).append('[');
        } else {
            // Need to re-apply prefix colors if bracket color is default
            formatted.append(ChatColor.getLastColors(prefix)).append('[');
        }

        // Apply content color
        if (contentColor != null) {
            // Append content with its new color
            formatted.append(contentColor).append(content);
        } else {
            // If content color is default, try to determine the original content color
             String originalInside = originalDisplay.substring(openBracketIndex + 1, closeBracketIndex);
             String lastColorInside = ChatColor.getLastColors(originalInside);
             if (!lastColorInside.isEmpty()) {
                 // Apply original internal color if found
                 formatted.append(lastColorInside).append(content);
             } else {
                 // Fallback: Apply the color that was active just before the content (either prefix or bracket color)
                 String colorBeforeContentStr = ChatColor.getLastColors(prefix);
                 if (bracketColor != null) {
                    colorBeforeContentStr = bracketColor.toString();
                 }
                 formatted.append(colorBeforeContentStr).append(content);
             }
        }

        // Apply bracket color to closing bracket
        if (bracketColor != null) {
            formatted.append(bracketColor).append(']');
        } else {
            // Re-apply prefix colors if bracket color is default
             formatted.append(ChatColor.getLastColors(prefix)).append(']');
        }

        // Append the original suffix directly. Let Minecraft handle color context continuation.
        formatted.append(suffix);

        return formatted.toString();
    }


    public void setPlayerTag(Player player, String tagName, TagType tagType) {
        getLogger().info("[uTags Temp Debug] setPlayerTag called for " + player.getName() + " with tag " + tagName);
        User user = getLuckPerms().getUserManager().getUser(player.getUniqueId());
        if (user == null) {
            getLogger().warning("Could not find LuckPerms user for " + player.getName());
            return;
        }

        // Fetch the display string for the tag asynchronously
        getTagDisplayByNameAsync(tagName).thenAcceptAsync(displayString -> {
            if (displayString == null || displayString.isEmpty()) {
                getLogger().warning("Could not find display string for tag: " + tagName);
                // Optionally send a message to the player
                Bukkit.getScheduler().runTask(this, () -> player.sendMessage(ChatColor.RED + "Error applying tag: Could not find tag display."));
                return;
            }

            // Remove the outer declaration, it will be handled inside the if/else blocks

            if (tagType == TagType.PREFIX) {
                // 1. Get the base display string for the new tag
                String newTagBaseDisplay = displayString; // Use the raw display string from the tag object

                // Steps 2 & 3 (Tag/Name color preferences) removed as per new logic for prefix node value
                // String finalNameColor = (nameColorCode != null) ? nameColorCode : "&f"; // Name color not needed for prefix node itself

                // 4. Prepare the base for the prefix node value
                // String prefixValue = newTagBaseDisplay; // We'll construct the final value later

                // --- Step 5: Find existing uTags prefix node and extract trailing color ---
                String preservedTrailingColorCode = "§f"; // Default to white (§f)
                Node existingPrefixNodeToRemove = null; // Stores the node to be removed
                getLogger().fine("[uTags] Searching for existing prefix node with priority " + TAG_PREFIX_PRIORITY + " for " + player.getName());

                // Iterate through the user's nodes to find the specific prefix node
                for (Node node : user.data().toCollection()) {
                    if (node instanceof PrefixNode && ((PrefixNode) node).getPriority() == TAG_PREFIX_PRIORITY) {
                        existingPrefixNodeToRemove = node; // Found the node to remove
                        PrefixNode prefixNode = (PrefixNode) node;
 
                        // Extract prefix value from the node key (prefix.<priority>.<value>) - Reverted change
                        String nodeKey = prefixNode.getKey();
                        String prefixKeyPrefix = "prefix." + TAG_PREFIX_PRIORITY + ".";
                        String existingValue = null;
                        if (nodeKey.startsWith(prefixKeyPrefix)) {
                            existingValue = nodeKey.substring(prefixKeyPrefix.length());
                        } else {
                             getLogger().warning("[uTags] Found prefix node with correct priority, but key format unexpected: " + nodeKey);
                             // Handle error or break if necessary, for now, existingValue remains null
                        }
                        getLogger().info("[uTags Debug] Retrieved existing prefix value (from key): '" + (existingValue != null ? existingValue.replace(String.valueOf(ChatColor.COLOR_CHAR), "&") : "null") + "' for " + player.getName()); // Keep log, clarify source

                       // Extract the *last* color code from the existing value
                       if (existingValue != null && !existingValue.isEmpty()) {
                           int lastColorIndex = existingValue.lastIndexOf(ChatColor.COLOR_CHAR);
                           // Check if '§' exists and is followed by a valid code character
                           if (lastColorIndex != -1 && lastColorIndex < existingValue.length() - 1) {
                               char codeChar = existingValue.charAt(lastColorIndex + 1);
                               // Basic check for valid color/format codes
                               if ("0123456789abcdefklmnor".indexOf(Character.toLowerCase(codeChar)) != -1) {
                                   preservedTrailingColorCode = existingValue.substring(lastColorIndex, lastColorIndex + 2);
                                   getLogger().info("[uTags Debug] Extracted trailing color code: '" + preservedTrailingColorCode.replace(String.valueOf(ChatColor.COLOR_CHAR), "&") + "' for " + player.getName());
                               } else {
                                   getLogger().info("[uTags Debug] Found '§' but not a valid color/format code at the end of existing tag value for " + player.getName() + ". Using default ('§f').");
                                   getLogger().info("[uTags Debug] Extracted trailing color code: '§f' (default) for " + player.getName()); // Log default explicitly
                               }
                           } else {
                                getLogger().info("[uTags Debug] No color code found at the end of existing tag value for " + player.getName() + ". Using default ('§f').");
                                getLogger().info("[uTags Debug] Extracted trailing color code: '§f' (default) for " + player.getName()); // Log default explicitly
                           }
                       } else {
                           getLogger().info("[uTags Debug] Existing uTags prefix node has null or empty value for " + player.getName() + ". Using default color ('§f').");
                           getLogger().info("[uTags Debug] Extracted trailing color code: '§f' (default) for " + player.getName()); // Log default explicitly
                       }
                        break; // Found the relevant node, exit loop
                    }
                }

                // --- Step 6: Remove the existing uTags prefix node (if found) ---
                if (existingPrefixNodeToRemove != null) {
                    user.data().remove(existingPrefixNodeToRemove);
                    getLogger().fine("[uTags] Removed existing uTags prefix node for " + player.getName());
                } else {
                    getLogger().fine("[uTags] No existing uTags prefix node found to remove for " + player.getName());
                }

                // --- Step 7: Determine final name color and construct the new prefix value ---
                // Use the preserved trailing color code (defaults to "§f" if none was found)
                getLogger().fine("[uTags] Final trailing color code to append: " + preservedTrailingColorCode.replace(String.valueOf(ChatColor.COLOR_CHAR), "&"));

                // --- Step 7b: Apply Player-Specific Colors ---
                // Get the player's color preference for this specific tag
                PlayerTagColorPreference colorPref = getPlayerTagColorPreference(player.getUniqueId(), tagName);
                // Format the tag display using the player's preference (or defaults if none)
                String colorFormattedTagDisplay = formatTagDisplayWithColor(newTagBaseDisplay, colorPref);
                getLogger().info("[uTags Debug] Color-formatted tag string: '" + colorFormattedTagDisplay.replace(String.valueOf(ChatColor.COLOR_CHAR), "&") + "' for " + player.getName());

                // Combine the *color-formatted* tag display with the preserved/default trailing color code
                String finalPrefixValue = colorFormattedTagDisplay + preservedTrailingColorCode; // Use the formatted display
                getLogger().info("[uTags Debug] Final combined prefix string: '" + finalPrefixValue.replace(String.valueOf(ChatColor.COLOR_CHAR), "&") + "' for " + player.getName());

                // 8. Add the new uTags prefix node
                user.data().add(PrefixNode.builder(finalPrefixValue, TAG_PREFIX_PRIORITY).build()); // Add node with new base display + old color

                // 9. Store the applied tag NAME for later color updates
                playerAppliedPrefixTagName.put(player.getUniqueId(), tagName);

                // 10. Declare the prefix string as final HERE, right before the save logic that uses it
                // The final prefix value was already constructed and assigned on line 1093

                // 11. Save user data and schedule refresh
                getLogger().info("[uTags Temp Debug] Attempting to save user " + player.getName() + " with updated prefix node in setPlayerTag");
                getLuckPerms().getUserManager().saveUser(user)
                    .exceptionally(ex -> {
                        getLogger().severe("Failed to save user " + player.getName() + " in setPlayerTag (prefix): " + ex.getMessage());
                        // ex.printStackTrace(); // Optionally uncomment for full stack trace
                        return null; // Required for exceptionally
                    })
                    .thenRunAsync(() -> {
                    // Existing callback logic...
                    getLogger().info("[UTags Temp Debug] saveUser callback started for " + player.getName()); // Keep this log
                    getLogger().fine("setPlayerTag (prefix) save complete for " + player.getName() + ". Reloading user and updating display name directly.");

                    // Directly schedule the final display name update on the main thread
                    Bukkit.getScheduler().runTask(this, () -> {
                        try {
                            // Get the LuckPerms user again inside the task to ensure we have the latest reference
                            User currentUser = luckPerms.getUserManager().getUser(player.getUniqueId());
                            if (currentUser == null) {
                                getLogger().warning("[uTags] Could not find LuckPerms user for " + player.getName() + " during final display name update.");
                                return; // Exit if user not found
                            }

            // [Code removed from here and moved earlier]
                            // Get prefix and suffix from the user's cached data
                            String prefix = currentUser.getCachedData().getMetaData().getPrefix();
                            String suffix = currentUser.getCachedData().getMetaData().getSuffix();
                            String name = player.getName();
                            String reset = ChatColor.RESET.toString(); // Ensure reset code is included

                            // Construct the final display name
                            // Note: Name color is implicitly handled by LuckPerms suffix/prefix if configured correctly.
                            // We just assemble the parts provided by the cached metadata.
                            String finalDisplayName = (prefix != null ? ChatColor.translateAlternateColorCodes('&', prefix) : "") +
                                                      name + // Base name, color should come from prefix/suffix
                                                      (suffix != null ? ChatColor.translateAlternateColorCodes('&', suffix) : "") +
                                                      reset; // Add reset at the end

                            getLogger().fine("[uTags] Constructed display name for " + name + ": " + finalDisplayName);

                            // Set the display name and list name
                            player.setDisplayName(finalDisplayName);
                            player.setPlayerListName(finalDisplayName); // Update list name too

                            getLogger().info("[uTags] Successfully updated display name for " + name + " after tag set.");
                            getLogger().info("[uTags Debug] saveUser complete and display name updated for " + name + " in setPlayerTag (prefix)"); // Final confirmation log

                        } catch (Exception e) {
                            getLogger().severe("[uTags] Failed to set final display name for " + player.getName() + " after tag save: " + e.getMessage());
                            e.printStackTrace(); // Log the full stack trace for debugging
                        }
                    });

                }, runnable -> Bukkit.getScheduler().runTask(this, runnable)); // Ensure Bukkit tasks run on main thread

            } else if (tagType == TagType.SUFFIX) {
                // Suffix logic remains unchanged for now, using the display string directly
                user.data().clear(NodeType.SUFFIX.predicate());
                user.data().add(SuffixNode.builder(displayString, 10000).build());

                // Save the user data asynchronously (Suffix doesn't need the special prefix handling)
                getLogger().info("[uTags Temp Debug] Attempting to save user " + player.getName() + " with updated suffix node in setPlayerTag");
                getLuckPerms().getUserManager().saveUser(user)
                    .exceptionally(ex -> {
                        getLogger().severe("Failed to save user " + player.getName() + " in setPlayerTag (suffix): " + ex.getMessage());
                        // ex.printStackTrace(); // Optionally uncomment for full stack trace
                        return null; // Required for exceptionally
                    })
                    .thenRunAsync(() -> {
                    // Existing callback logic...
                    getLogger().info("[UTags Temp Debug] saveUser callback started for " + player.getName()); // Keep this log
                    getLogger().fine("setPlayerTag (suffix) save complete for " + player.getName() + ". Reloading user and updating display name directly.");

                    // Load the user again to get the most up-to-date data after save
                    luckPerms.getUserManager().loadUser(player.getUniqueId()).thenAcceptAsync(userToRecalc -> {
                        getLogger().fine("Invalidating cached data for " + player.getName() + " after suffix update.");
                        userToRecalc.getCachedData().invalidate(); // Invalidate cache

                        // Directly update the display name on the main thread using the recalculated data
                        Bukkit.getScheduler().runTask(this, () -> {
                            try {
                                // Get the calculated prefix and suffix from the reloaded user's metadata
                                // Directly access prefix/suffix from getMetaData() result
                                String prefix = userToRecalc.getCachedData().getMetaData().getPrefix(); // Get current prefix
                                String suffix = userToRecalc.getCachedData().getMetaData().getSuffix(); // This should reflect the change we just saved
                                // Format the display name
                                String baseName = player.getName();
                                String currentNameColorCode = getPlayerNameColorCode(player.getUniqueId()); // Renamed variable
                                String finalNameColor = (currentNameColorCode != null) ? currentNameColorCode : "&f"; // Use renamed variable

                                String formattedName = (prefix != null ? ChatColor.translateAlternateColorCodes('&', prefix) : "") +
                                                       ChatColor.translateAlternateColorCodes('&', finalNameColor) + baseName +
                                                       (suffix != null ? ChatColor.translateAlternateColorCodes('&', suffix) : "");

                                getLogger().fine("Directly setting display name for " + player.getName() + " after suffix update to: " + formattedName);
                                player.setDisplayName(formattedName);
                                player.setPlayerListName(formattedName); // Update list name too

                            } catch (Exception e) {
                                getLogger().severe("Error directly updating display name for " + player.getName() + " after suffix set: " + e.getMessage());
                                e.printStackTrace();
                            }
                        });

                    }, runnable -> Bukkit.getScheduler().runTaskAsynchronously(this, runnable)); // Run user loading/cache invalidation async

                }, runnable -> Bukkit.getScheduler().runTask(this, runnable)); // Ensure Bukkit tasks run on main thread
            }

            // Remove this entire redundant save block

        }, runnable -> Bukkit.getScheduler().runTask(this, runnable)); // Ensure Bukkit tasks run on main thread
    }

    /**
     * Asynchronously retrieves the internal tag name based on its display value.
     *
     * @param display The display value of the tag.
     * @return A CompletableFuture containing the internal tag name, or null if not found or an error occurs.
     */
    public CompletableFuture<String> getTagNameByDisplayAsync(String display) {
        return CompletableFuture.supplyAsync(() -> {
            String tagName = null;
            try (Connection connection = getConnection();
                 PreparedStatement statement = connection.prepareStatement("SELECT name FROM tags WHERE display = ? LIMIT 1;")) { // Optimized query
                statement.setString(1, display);
                ResultSet resultSet = statement.executeQuery();
                if (resultSet.next()) {
                    tagName = resultSet.getString("name");
                }
            } catch (SQLException e) {
                getLogger().severe("Error fetching tag name by display '" + display + "': " + e.getMessage());
                e.printStackTrace(); // Log the stack trace for debugging
                // Optionally, complete exceptionally: future.completeExceptionally(e);
                // For simplicity here, we return null on error.
            }
            return tagName;
        });
    }

    /**
     * Asynchronously retrieves the display value of a tag based on its internal name.
     *
     * @param name The internal name of the tag.
     * @return A CompletableFuture containing the display value, or null if not found or an error occurs.
     */
    public CompletableFuture<String> getTagDisplayByNameAsync(String name) {
        return CompletableFuture.supplyAsync(() -> {
            String tagDisplay = null;
            try (Connection connection = getConnection();
                 PreparedStatement statement = connection.prepareStatement("SELECT display FROM tags WHERE name = ? LIMIT 1;")) { // Optimized query
                statement.setString(1, name);
                ResultSet resultSet = statement.executeQuery();
                if (resultSet.next()) {
                    tagDisplay = resultSet.getString("display");
                }
            } catch (SQLException e) {
                getLogger().severe("Error fetching tag display by name '" + name + "': " + e.getMessage());
                e.printStackTrace(); // Log the stack trace for debugging
                // Optionally, complete exceptionally: future.completeExceptionally(e);
                // For simplicity here, we return null on error.
            }
            return tagDisplay;
        });
}

    /**
     * Synchronously retrieves the display value of a tag based on its internal name.
     * Use getTagDisplayByNameAsync for better performance when possible.
     *
     * @param name The internal name of the tag.
     * @return The display value, or null if not found or an error occurs.
     */
    public String getTagDisplayByName(String name) {
        String tagDisplay = null;
        try (Connection connection = getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT display FROM tags WHERE name = ? LIMIT 1;")) {
            statement.setString(1, name);
            ResultSet resultSet = statement.executeQuery();
            if (resultSet.next()) {
                tagDisplay = resultSet.getString("display");
            }
        } catch (SQLException e) {
            getLogger().severe("Error fetching tag display synchronously by name '" + name + "': " + e.getMessage());
            e.printStackTrace();
        }
        return tagDisplay;
    }


    // Keep the synchronous version for now if needed elsewhere, or remove if fully replaced
    // public String getTagDisplayByName(String name) { ... }


    /**
     * Retrieves a Tag object from the database based on its internal name.
     * Returns null if the tag is not found or an error occurs.
     */
    public Tag getTagByName(String name) {
        Tag tag = null;
        try (Connection connection = getConnection();
             PreparedStatement statement = connection.prepareStatement("SELECT * FROM tags WHERE name = ?")) {

            statement.setString(1, name);
            ResultSet resultSet = statement.executeQuery();

            if (resultSet.next()) {
                tag = createTagFromResultSet(resultSet); // Reuse existing creation logic
            }
        } catch (SQLException e) {
            getLogger().severe("Error retrieving tag by name '" + name + "': " + e.getMessage());
            e.printStackTrace();
        }
        return tag;
    }

    public void addPreviewTag(Player player, String tag) {
        previewTags.put(player.getUniqueId(), tag);
    }

    public Map<UUID, String> getPreviewTags()
    {
        return previewTags;
    }


    /**
     * Gets the specific color preference for a player and tag.
     * If no preference exists, it returns a default preference object (with null colors).
     *
     * @param playerUuid The UUID of the player.
     * @param tagName    The internal name of the tag.
     * @return The PlayerTagColorPreference object, never null.
     */
    public PlayerTagColorPreference getPlayerTagColorPreference(UUID playerUuid, String tagName) {
        return playerColorPreferences
                .computeIfAbsent(playerUuid, k -> new ConcurrentHashMap<>())
                .computeIfAbsent(tagName, k -> new PlayerTagColorPreference(playerUuid, tagName));
    }

    /**
     * Sets the custom color preference for a player and a specific tag.
     * Using null for a color means reverting that part (bracket or content) to the tag's default color.
     * If both colors are null, the preference entry might be removed for cleanup (optional optimization).
     *
     * @param playerUuid   The UUID of the player.
     * @param tagName      The internal name of the tag.
     * @param bracketColor The desired ChatColor for the brackets, or null to use default.
     * @param contentColor The desired ChatColor for the content, or null to use default.
     */
    public void setPlayerTagColor(UUID playerUuid, String tagName, ChatColor bracketColor, ChatColor contentColor) {
        // 1. Update in-memory map (immediate feedback)
        Map<String, PlayerTagColorPreference> playerPrefs = playerColorPreferences
                .computeIfAbsent(playerUuid, k -> new ConcurrentHashMap<>());

        boolean removedInMemory = false;
        if (bracketColor == null && contentColor == null) {
            // Remove from memory if both colors are null (reset)
            playerPrefs.remove(tagName);
            if (playerPrefs.isEmpty()) {
                playerColorPreferences.remove(playerUuid);
            }
            removedInMemory = true;
        } else {
            // Update or create preference in memory
            PlayerTagColorPreference pref = playerPrefs
                    .computeIfAbsent(tagName, k -> new PlayerTagColorPreference(playerUuid, tagName));
            pref.setBracketColor(bracketColor);
            pref.setContentColor(contentColor);
        }

        // --- Immediate LuckPerms Update if Wearing This Tag ---
        String appliedTagName = playerAppliedPrefixTagName.get(playerUuid);
        if (appliedTagName != null && appliedTagName.equals(tagName)) {
            Player player = Bukkit.getPlayer(playerUuid);
            if (player != null && player.isOnline()) {
                getLogger().info("[uTags] Player " + player.getName() + " is wearing the tag being color-modified (" + tagName + "). Updating LuckPerms prefix.");

                // Get the newly set preference (could be null if reset)
                PlayerTagColorPreference newColorPref = playerPrefs.get(tagName);

                // Perform the update asynchronously
                CompletableFuture.runAsync(() -> {
                    User user = luckPerms.getUserManager().getUser(playerUuid);
                    if (user == null) {
                        getLogger().warning("Could not load LuckPerms user for immediate tag color update: " + player.getName());
                        return;
                    }

                    // Fetch the base display string for the tag
                    String baseTagDisplay = getTagDisplayByName(tagName);
                    if (baseTagDisplay == null) {
                         getLogger().warning("Could not find base display for tag '" + tagName + "' during color update for " + player.getName());
                         return;
                    }

                    // --- Find existing uTags prefix node and extract trailing color ---
                    String preservedTrailingColorCode = "§f"; // Default to white (§f)
                    Node existingPrefixNodeToRemove = null;

                    for (Node node : user.data().toCollection()) {
                        if (node instanceof PrefixNode && ((PrefixNode) node).getPriority() == TAG_PREFIX_PRIORITY) {
                            existingPrefixNodeToRemove = node;
                            PrefixNode prefixNode = (PrefixNode) node;
                            String nodeKey = prefixNode.getKey();
                            String prefixKeyPrefix = "prefix." + TAG_PREFIX_PRIORITY + ".";
                            String existingValue = null;
                            if (nodeKey.startsWith(prefixKeyPrefix)) {
                                existingValue = nodeKey.substring(prefixKeyPrefix.length());
                            } else {
                                 getLogger().warning("[uTags] Found prefix node with correct priority, but key format unexpected: " + nodeKey);
                            }

                           if (existingValue != null && !existingValue.isEmpty()) {
                               int lastColorIndex = existingValue.lastIndexOf(ChatColor.COLOR_CHAR);
                               if (lastColorIndex != -1 && lastColorIndex < existingValue.length() - 1) {
                                   char codeChar = existingValue.charAt(lastColorIndex + 1);
                                   if ("0123456789abcdefklmnor".indexOf(Character.toLowerCase(codeChar)) != -1) {
                                       preservedTrailingColorCode = existingValue.substring(lastColorIndex, lastColorIndex + 2);
                                   }
                               }
                           }
                            getLogger().fine("[uTags Debug] Extracted trailing color code during color update: '" + preservedTrailingColorCode.replace(String.valueOf(ChatColor.COLOR_CHAR), "&") + "' for " + player.getName());
                            break;
                        }
                    }

                    // --- Remove the existing uTags prefix node (if found) ---
                    if (existingPrefixNodeToRemove != null) {
                        user.data().remove(existingPrefixNodeToRemove);
                        getLogger().fine("[uTags] Removed existing uTags prefix node for " + player.getName() + " during color update.");
                    }

                    // --- Format tag with NEW colors and combine with preserved name color ---
                    String colorFormattedTagDisplay = formatTagDisplayWithColor(baseTagDisplay, newColorPref); // Use the new preference
                    String finalPrefixValue = colorFormattedTagDisplay + preservedTrailingColorCode;
                    getLogger().info("[uTags Debug] Final combined prefix string during color update: '" + finalPrefixValue.replace(String.valueOf(ChatColor.COLOR_CHAR), "&") + "' for " + player.getName());

                    // --- Add the new uTags prefix node ---
                    user.data().add(PrefixNode.builder(finalPrefixValue, TAG_PREFIX_PRIORITY).build());

                    // --- Save user data and schedule refresh ---
                    luckPerms.getUserManager().saveUser(user)
                        .exceptionally(ex -> {
                            getLogger().severe("Failed to save user " + player.getName() + " after immediate tag color update: " + ex.getMessage());
                            return null;
                        })
                        .thenRunAsync(() -> {
                            getLogger().fine("LuckPerms save complete for " + player.getName() + " after tag color update. Triggering display name refresh.");
                            // Use the existing refresh mechanism
                            refreshBukkitDisplayName(player);
                        }, runnable -> Bukkit.getScheduler().runTask(this, runnable)); // Ensure Bukkit tasks run on main thread

                }); // End CompletableFuture.runAsync for LuckPerms update
            } else {
                 getLogger().warning("[uTags] Player " + playerUuid + " is wearing tag " + tagName + " but is offline. Skipping immediate LuckPerms update.");
            }
        } else {
             getLogger().fine("[uTags] Player " + playerUuid + " is not wearing the tag being color-modified (" + tagName + "). Skipping immediate LuckPerms update.");
        }

        // 2. Persist change to database asynchronously (This runs regardless of whether the tag was worn)
        final boolean finalRemovedInMemory = removedInMemory; // Need final variable for lambda
        CompletableFuture.runAsync(() -> {
            String bracketCode = (bracketColor != null) ? "&" + bracketColor.getChar() : null;
            String contentCode = (contentColor != null) ? "&" + contentColor.getChar() : null;

            try (Connection conn = getConnection()) {
                if (finalRemovedInMemory) {
                    // Delete the row if colors were reset in memory
                    String deleteSql = "DELETE FROM player_tag_color_preferences WHERE player_uuid = ? AND tag_name = ?";
                    try (PreparedStatement ps = conn.prepareStatement(deleteSql)) {
                        ps.setString(1, playerUuid.toString());
                        ps.setString(2, tagName);
                        int rowsAffected = ps.executeUpdate();
                        if (rowsAffected > 0) {
                            getLogger().fine("Removed tag color preference from DB for " + playerUuid + ", tag: " + tagName);
                        }
                    }
                } else {
                    // Insert or update the row
                    String upsertSql = "INSERT INTO player_tag_color_preferences (player_uuid, tag_name, bracket_color_code, content_color_code) " +
                                       "VALUES (?, ?, ?, ?) " +
                                       "ON DUPLICATE KEY UPDATE bracket_color_code = VALUES(bracket_color_code), content_color_code = VALUES(content_color_code)";
                    try (PreparedStatement ps = conn.prepareStatement(upsertSql)) {
                        ps.setString(1, playerUuid.toString());
                        ps.setString(2, tagName);
                        // Handle nulls for SQL
                        if (bracketCode != null) ps.setString(3, bracketCode); else ps.setNull(3, Types.VARCHAR);
                        if (contentCode != null) ps.setString(4, contentCode); else ps.setNull(4, Types.VARCHAR);

                        ps.executeUpdate();
                        getLogger().fine("Saved tag color preference to DB for " + playerUuid + ", tag: " + tagName);
                    }
                }
            } catch (SQLException e) {
                getLogger().severe("Failed to save player tag color preference to database for " + playerUuid + ", tag: " + tagName + ". Error: " + e.getMessage());
                e.printStackTrace(); // Log stack trace for debugging
            }
        });
    }

    /**
     * Resets the color preference for a specific player and tag back to the default.
     *
     * @param playerUuid The UUID of the player.
     * @param tagName    The internal name of the tag.
     */
    public void resetPlayerTagColor(UUID playerUuid, String tagName) {
        setPlayerTagColor(playerUuid, tagName, null, null); // Setting both to null effectively resets
    }

    // --- Name Color Preference Methods ---

    /**
     * Asynchronously loads all player name color preferences from the database into the cache.
     * Should be called on plugin enable.
     */
    private void loadAllPlayerNameColorsAsync() {
        CompletableFuture.runAsync(() -> {
            try (Connection conn = getConnection();
                 PreparedStatement ps = conn.prepareStatement("SELECT player_uuid, name_color_code FROM player_preferences");
                 ResultSet rs = ps.executeQuery()) {

                int count = 0;
                while (rs.next()) {
                    try {
                        UUID uuid = UUID.fromString(rs.getString("player_uuid"));
                        String colorCode = rs.getString("name_color_code"); // Can be null
                        playerNameColorPreferences.put(uuid, colorCode);
                        count++;
                    } catch (IllegalArgumentException e) {
                        getLogger().warning("Invalid UUID found in player_preferences table: " + rs.getString("player_uuid"));
                    }
                }
                getLogger().info("Loaded " + count + " player name color preferences.");

            } catch (SQLException e) {
                getLogger().severe("Failed to load player name color preferences: " + e.getMessage());
                e.printStackTrace();
            }
        });
    }


    /**
     * Asynchronously saves a player's name color preference to the database and updates the cache.
     *
     * @param playerUuid The UUID of the player.
     * @param colorCode  The color code string (e.g., "&a") or null to reset.
     */
    public void savePlayerNameColorCode(UUID playerUuid, String colorCode) {
        // Update cache immediately
        String finalColorCode = (colorCode == null || colorCode.equalsIgnoreCase("reset")) ? null : colorCode; // Treat "reset" as null
        if (finalColorCode == null) {
            playerNameColorPreferences.remove(playerUuid);
        } else {
            playerNameColorPreferences.put(playerUuid, finalColorCode);
        }

        // Save to DB asynchronously and then update LuckPerms/display name
        CompletableFuture.runAsync(() -> {
            String sql = "REPLACE INTO player_preferences (player_uuid, name_color_code) VALUES (?, ?)";
            try (Connection conn = getConnection();
                 PreparedStatement ps = conn.prepareStatement(sql)) {

                ps.setString(1, playerUuid.toString());
                ps.setString(2, finalColorCode); // Use finalColorCode (handles null)
                ps.executeUpdate();

                // DB save successful. Now schedule the display name update on the main thread.
                // updatePlayerDisplayName will handle applying the name color via the suffix node.
                Bukkit.getScheduler().runTask(this, () -> {
                    Player onlinePlayer = Bukkit.getPlayer(playerUuid);
                    if (onlinePlayer != null && onlinePlayer.isOnline()) {
                        getLogger().fine("Name color preference saved for " + onlinePlayer.getName() + ". Triggering display name update.");
                        updatePlayerDisplayName(onlinePlayer); // Call the method that handles suffix and display name refresh
                    } else {
                         getLogger().fine("Name color preference saved for offline UUID " + playerUuid + ". Display name update skipped.");
                    }
                });

            } catch (SQLException e) {
                getLogger().severe("Failed to save name color preference for " + playerUuid + ": " + e.getMessage());
                e.printStackTrace();
                // Consider reverting cache change or marking as dirty? For now, log the error.
            }
        });
    }

    /**
     * Gets the player's chosen name color from the cache.
     *
     * @param playerUuid The UUID of the player.
     * @return The ChatColor preference, or ChatColor.WHITE if not set or invalid.
     */
    public ChatColor getPlayerNameColor(UUID playerUuid) {
        String colorCode = playerNameColorPreferences.get(playerUuid);

        if (colorCode == null || colorCode.length() != 2 || colorCode.charAt(0) != '&') {
            return ChatColor.WHITE; // Default if not set or invalid format
        }

        ChatColor color = ChatColor.getByChar(colorCode.charAt(1));
        return (color != null && color.isColor()) ? color : ChatColor.WHITE; // Return valid color or default
    }

    /**
     * Gets the internal map storing player name color preferences.
     * Primarily intended for testing or specific internal uses.
     *
     * @return The map of player UUIDs to color codes.
     */
    public Map<UUID, String> getPlayerNameColorPreferencesMap() {
        return playerNameColorPreferences;
    }

    // Cleaned up stray brace and comment



    /**
     * Gets the player's preferred name color code from the cache.
     * Returns null if no preference is set (use default).
     *
     * @param playerUuid The UUID of the player.
     * @return The color code string (e.g., "&a") or null.
     */
    public String getPlayerNameColorCode(UUID playerUuid) {
        return playerNameColorPreferences.get(playerUuid); // Returns null if not found, which is desired
    }


    // --- Message Utility ---

    /**
     * Gets a message from the config.yml, translates color codes, and handles missing keys.
     *
     * @param key The configuration key for the message.
     * @return The formatted message string.
     */
    public String getMessage(String key) {
        String message = getConfig().getString("messages." + key);
        if (message == null) {
            getLogger().warning("Missing message key in config.yml: messages." + key);
            return ChatColor.RED + "Error: Missing message for " + key; // Fallback message
        }
        return ChatColor.translateAlternateColorCodes('&', message);
    }


    // --- Display Name Update ---

    /**
     * Updates the player's display name based on their stored name color preference.
     * This should be called on login and after changing the name color.
     * It respects LuckPerms prefixes/suffixes.
     *
     * @param player The player whose display name should be updated.
     */
    public void updatePlayerDisplayName(Player player) {
        // getLogger().info("[uTags Debug] updatePlayerDisplayName called for " + player.getName()); // Optional: Keep if needed
        if (player == null || !player.isOnline()) {
            return;
        }

        UUID playerUuid = player.getUniqueId();
        String baseName = player.getName(); // Keep base name for potential future use

        // Get the intended name color code from cache FIRST
        String intendedNameColorCode = getPlayerNameColorCode(playerUuid); // e.g., "&a", or null for default
        getLogger().info("[uTags Debug] Intended name color code for " + player.getName() + ": '" + (intendedNameColorCode != null ? intendedNameColorCode : "none") + "'"); // Requirement 6.3

        // Load the LuckPerms user asynchronously for modification
        luckPerms.getUserManager().loadUser(playerUuid).thenAcceptAsync(user -> {
            if (user == null) {
                getLogger().warning("Could not load LuckPerms user for display name update: " + player.getName());
                return;
            }

            // --- Prefix Handling Logic for Name Color ---
            PrefixNode currentTagPrefixNode = null;
            String currentPrefixValue = ""; // Default to empty string if no prefix node found

            // Find the existing prefix node managed by uTags (using TAG_PREFIX_PRIORITY)
            for (Node node : user.getNodes(NodeType.PREFIX)) {
                if (node instanceof PrefixNode) {
                    PrefixNode prefixNode = (PrefixNode) node;
                    if (prefixNode.getPriority() == TAG_PREFIX_PRIORITY) {
                        currentTagPrefixNode = prefixNode;
                        currentPrefixValue = prefixNode.getMetaValue();
                        break; // Found the relevant prefix node
                    }
                }
            }
            // Log retrieved prefix *before* checking if it's empty (Requirement 1a / 2)
            getLogger().info("[uTags Debug] Retrieved existing uTags prefix node value for " + player.getName() + ": '" + currentPrefixValue + "'");

            // Requirement 1a: Check if the retrieved prefix is null or empty. Stop if it is.
            // Note: currentPrefixValue defaults to "" if no node is found, so we check isEmpty().
            // If a node *must* exist for the /name command to work, this logic might need adjustment
            // based on whether an empty prefix node is valid or implies an error state.
            // Assuming for now that an empty/non-existent prefix means we cannot proceed with name color update.
            if (currentPrefixValue.isEmpty()) {
                 getLogger().severe("[uTags Error] Cannot update name color for " + player.getName() + ": Existing uTags prefix node (priority " + TAG_PREFIX_PRIORITY + ") is missing or empty.");
                 // Optionally, attempt to reset the display name if this state is unexpected
                 // Bukkit.getScheduler().runTask(this, () -> refreshBukkitDisplayName(player));
                 return; // Stop processing for this user
            }


            // --- Extract Base Tag Part --- Requirement 1b / 2
            String baseTagPart = null;
            String appliedTagName = playerAppliedPrefixTagName.get(playerUuid); // Check if we know which tag is applied

            if (appliedTagName != null) {
                Tag appliedTag = getTagByName(appliedTagName); // Attempt to fetch the Tag object
                if (appliedTag != null) {
                    // Preferred method: Use the original display string of the applied tag
                    baseTagPart = appliedTag.getDisplay();
                    getLogger().info("[uTags Debug] Extracted base tag part for " + player.getName() + " from applied tag '" + appliedTagName + "': '" + baseTagPart + "'");
                } else {
                    getLogger().warning("[uTags Debug] Could not find tag definition for applied tag name '" + appliedTagName + "' for player " + player.getName() + ". Falling back to parsing current prefix.");
                }
            } else {
                getLogger().warning("[uTags Debug] No applied tag name found in map for player " + player.getName() + ". Falling back to parsing current prefix.");
            }

            // Fallback: If we couldn't get the base tag from the map/DB, parse the current prefix value
            if (baseTagPart == null) {
                 // Find the last color code (& followed by 0-9a-fA-Fk-oK-OrR)
                 int lastColorCodeIndex = -1;
                 for (int i = currentPrefixValue.length() - 2; i >= 0; i--) {
                     if (currentPrefixValue.charAt(i) == '&' && "0123456789abcdefABCDEFkKlLmMnNoOrR".indexOf(currentPrefixValue.charAt(i + 1)) != -1) {
                         lastColorCodeIndex = i;
                         break;
                     }
                 }

                 if (lastColorCodeIndex != -1) {
                     // Base part is everything before the last color code
                     baseTagPart = currentPrefixValue.substring(0, lastColorCodeIndex);
                     getLogger().info("[uTags Debug] Extracted base tag part for " + player.getName() + " using fallback (before last '&'): '" + baseTagPart + "'");
                 } else {
                     // If no color code found at the end, assume the whole prefix is the base tag part
                     // This might happen if the prefix doesn't end with a name color, which could be an issue itself.
                     baseTagPart = currentPrefixValue;
                     getLogger().warning("[uTags Debug] Extracted base tag part for " + player.getName() + " using fallback (no trailing color code found, using full prefix): '" + baseTagPart + "'");
                 }
            }

            // --- Construct New Prefix Value --- Requirement 3
            String newPrefixValue = baseTagPart + (intendedNameColorCode != null ? intendedNameColorCode : ""); // Append color code or nothing if null
            getLogger().info("[uTags Debug] Final combined string being set for " + player.getName() + ": '" + newPrefixValue + "'"); // Requirement 1c / 2

            // Determine if an update to the prefix node is needed
            boolean needsUpdate = false;
            if (currentTagPrefixNode == null && !newPrefixValue.isEmpty()) {
                 needsUpdate = true; // Adding a new prefix node
                 getLogger().fine("Needs update: Adding new prefix node for " + player.getName());
            } else if (currentTagPrefixNode != null && newPrefixValue.isEmpty()) {
                 needsUpdate = true; // Removing the existing prefix node (setting empty prefix)
                 getLogger().fine("Needs update: Removing prefix node for " + player.getName());
            } else if (currentTagPrefixNode != null && !currentPrefixValue.equals(newPrefixValue)) {
                 needsUpdate = true; // Changing the prefix value
                 getLogger().fine("Needs update: Changing prefix node for " + player.getName() + " from '" + currentPrefixValue + "' to '" + newPrefixValue + "'");
            } else {
                 getLogger().fine("No prefix update needed for " + player.getName() + ". Current: '" + currentPrefixValue + "', New: '" + newPrefixValue + "'");
            }


            // Perform prefix node modifications ONLY if needsUpdate is true
            if (needsUpdate) {
                // Remove the old uTags prefix node if it existed --- Requirement 4
                if (currentTagPrefixNode != null) {
                    user.data().remove(currentTagPrefixNode);
                    getLogger().info("[uTags Debug] Removed existing uTags prefix node for " + player.getName()); // Requirement 1d log refinement
                }
                // Add the new prefix node if the combined value is not empty --- Requirement 5
                if (!newPrefixValue.isEmpty()) {
                    PrefixNode newPrefixNode = PrefixNode.builder()
                            .prefix(newPrefixValue)
                            .priority(TAG_PREFIX_PRIORITY) // Use the same priority as tags
                            .build();
                    user.data().add(newPrefixNode);
                    getLogger().info("[uTags Debug] Added new uTags prefix node for " + player.getName() + " with value: '" + newPrefixValue + "'"); // Requirement 1e log refinement
                }

                // Save the user data ONLY if prefix changed
                luckPerms.getUserManager().saveUser(user).thenRunAsync(() -> {
                    getLogger().fine("LuckPerms saveUser complete for " + player.getName() + " after prefix update. Reloading user and updating display name directly.");

                    // Load the user again to get the most up-to-date data after save
                    luckPerms.getUserManager().loadUser(player.getUniqueId()).thenAcceptAsync(userToRecalc -> {
                        getLogger().fine("Invalidating cached data for " + player.getName() + " after prefix update.");
                        // It's crucial to invalidate the cache so the subsequent getMetaData() call reflects the changes
                        userToRecalc.getCachedData().invalidate();

                        // Directly update the display name on the main thread using the recalculated data
                        Bukkit.getScheduler().runTask(this, () -> {
                            try {
                                // Get the calculated prefix and suffix from the reloaded user's metadata
                                String prefix = userToRecalc.getCachedData().getMetaData().getPrefix(); // Get current prefix
                                String suffix = userToRecalc.getCachedData().getMetaData().getSuffix(); // Suffix remains unchanged by this logic

                                // Format the display name
                                String currentPlayerName = player.getName(); // Renamed variable

                                // The prefix now contains the tag AND the name color. The suffix is separate.
                                String formattedName = (prefix != null ? ChatColor.translateAlternateColorCodes('&', prefix) : "") +
                                                       currentPlayerName + // Player name itself doesn't need extra color here
                                                       (suffix != null ? ChatColor.translateAlternateColorCodes('&', suffix) : "");

                                getLogger().fine("Directly setting display name for " + player.getName() + " after prefix update to: " + formattedName);
                                player.setDisplayName(formattedName);
                                player.setPlayerListName(formattedName); // Update list name too
                                getLogger().info("[uTags Debug] Display name update triggered for " + player.getName() + " after saveUser and refresh."); // Requirement 1f / 2

                            } catch (Exception e) {
                                getLogger().severe("Error directly updating display name for " + player.getName() + " after prefix update: " + e.getMessage());
                                e.printStackTrace();
                            }
                        });

                    }, runnable -> Bukkit.getScheduler().runTaskAsynchronously(this, runnable)); // Run user loading/cache invalidation async

                }, runnable -> Bukkit.getScheduler().runTask(this, runnable)); // Ensure Bukkit tasks run on main thread

            } else {
                 // Prefix didn't change. Do nothing here.
                 getLogger().fine("No LuckPerms prefix update needed for " + player.getName() + ". No save/refresh scheduled from updatePlayerDisplayName.");
            }

        }).exceptionally(ex -> {
            getLogger().severe("Error during LuckPerms operations in updatePlayerDisplayName for " + player.getName() + ": " + ex.getMessage());
            ex.printStackTrace();
            // Attempt to reset display name on error
            Bukkit.getScheduler().runTask(this, () -> player.setDisplayName(player.getName()));
            return null;
        });
    }

    /**
     * Refreshes the player's Bukkit display name based on current LuckPerms data.
     * Should be called on the main server thread.
     */
    public void refreshBukkitDisplayName(Player player) {
        // This method is now just a trigger, called via Bukkit Scheduler on the main thread.
        // The actual work, including fresh data loading, happens in processDisplayNameRefresh.
        if (player == null || !player.isOnline()) {
            return;
        }
        // Directly call the processing method. It will handle async loading internally.
        processDisplayNameRefresh(player);
    }

    // Helper method to process the refresh logic after user is loaded
    // Helper method to process the refresh logic, now loading data freshly
    private void processDisplayNameRefresh(Player player) {
        if (player == null || !player.isOnline()) {
            getLogger().warning("[uTags Debug] Player is null or offline before starting processDisplayNameRefresh.");
            return; // Player logged out before task could even start
        }

        // Force a fresh load of user data directly from LuckPerms storage
        luckPerms.getUserManager().loadUser(player.getUniqueId()).thenAcceptAsync(loadedUser -> {
            getLogger().info("[uTags Debug] Inside loadUser callback for " + player.getName());
            // --- Start of async block ---
            // Ensure player is still valid *after* the async load completes
            if (loadedUser == null || player == null || !player.isOnline()) {
                getLogger().warning("[uTags Debug] User data loaded, but player " + (player != null ? player.getName() : "UNKNOWN") + " is now null or offline.");
                return;
            }

            // Fetch the prefix AND suffix from the *freshly loaded* user data's metadata
            net.luckperms.api.cacheddata.CachedMetaData metaData = loadedUser.getCachedData().getMetaData();
            String rawPrefixMeta = metaData.getPrefix();
            String suffix = metaData.getSuffix();

            getLogger().info("[uTags Debug] Freshly loaded meta for " + player.getName() + ": Prefix='" + rawPrefixMeta + "', Suffix='" + suffix + "'");
            // Ensure nulls become empty strings
            if (rawPrefixMeta == null) rawPrefixMeta = "";
            if (suffix == null) suffix = "";

            // Apply formatting only if the prefix isn't empty
            // Directly use the raw prefix from the fresh metadata
            String prefix = rawPrefixMeta.isEmpty() ? "" : rawPrefixMeta + " "; // Add space only if prefix exists

            // Construct the final display name: prefix + name + suffix + reset
            String finalDisplayName = prefix + player.getName() + suffix + ChatColor.RESET; // Use ChatColor.RESET

            getLogger().info("[uTags Debug] Processing refresh for " + player.getName() +
                    ". Freshly Loaded Raw Prefix Meta: '" + rawPrefixMeta +
                    "', Prefix: '" + prefix + // Changed variable name
                    "', Freshly Loaded Suffix: '" + suffix +
                    "', Final Name: '" + finalDisplayName + "'");

            // Set the display name on the Bukkit player object - MUST run on main thread
            final String nameToSet = finalDisplayName; // Final variable for lambda
            getLogger().info("[uTags Debug] Scheduling final display name set for " + player.getName());
            Bukkit.getScheduler().runTask(this, () -> {
                try {
                    // Double-check player validity right before setting
                    if (player != null && player.isOnline()) {
                        // --- Requested Debug Logging ---
                        // Log the exact values *before* applying them.
                        // 'nameToSet' contains the final calculated display name string.
                        // We can re-log the components used to build it from the outer scope if needed, but logging the final string is most direct.
                        getLogger().info(String.format("[uTags Debug] Applying Display Name (Main Thread): Player=%s, Final Calculated Name='%s'",
                                player.getName(), nameToSet));
                        // --- End Debug Logging ---

                        // Set the display name and player list name using Bukkit API
                        player.setDisplayName(nameToSet);
                        player.setPlayerListName(nameToSet); // Update tab list name as well

                        getLogger().info("[uTags Debug] Successfully set display name for " + player.getName() + " (main thread) to: " + nameToSet);
                    } else {
                         getLogger().warning("[uTags Debug] Player " + (player != null ? player.getName() : "UNKNOWN") + " became invalid just before setting display name on main thread.");
                    }
                } catch (Exception e) {
                    getLogger().severe("Error setting display name for " + player.getName() + " on main thread: " + e.getMessage());
                     getLogger().severe(String.format("Failed name: '%s'", nameToSet)); // Log the name that caused the error
                    e.printStackTrace();
                }
            });
            // --- End of async block ---

        }, runnable -> Bukkit.getScheduler().runTask(this, runnable)) // Ensure Bukkit tasks run on main thread for the async callback itself
        .exceptionally(ex -> {
             getLogger().severe("Error during async user load in processDisplayNameRefresh for " + player.getName() + ": " + ex.getMessage());
             ex.printStackTrace();
             // Attempt to reset display name on main thread in case of error during load
             Bukkit.getScheduler().runTask(this, () -> {
                 if (player != null && player.isOnline()) {
                    player.setDisplayName(player.getName());
                    player.setPlayerListName(player.getName());
                 }
             });
             return null;
         });
    }

}
</file>

</files>
